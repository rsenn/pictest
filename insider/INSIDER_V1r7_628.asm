; PROGRAM INSIDER VR. 1.7				***** WORKS *****
; ATANASIOS MELIMOPOULOS (pic.insider@gmail.com)

 list		p=16F628A, st=OFF

#include	<p16F628A.inc>
 errorlevel	-302
 errorlevel	-305
 radix	dec

 __CONFIG _WDT_OFF & _BODEN_OFF & _PWRTE_ON & _MCLRE_ON & _LVP_OFF & _HS_OSC

BAUD	EQU	.32	;SERIAL-BAUDRATE @20MHz: 129-9600 64-19200 32-38400 21-57600

;RX-TXINS VARS:
DB0	EQU	20H	;RX-TX INSIDER DATA
W1H	EQU	21H	;'1' DATA 512-PULSE WIDTH
W1L	EQU	22H
W0H	EQU	23H	;'0' DATA 256-PULSE WIDTH
W0L	EQU	24H
WTH	EQU	25H	;THRESHOLD 384-PULSE WIDTH
WTL	EQU	26H
TMPH	EQU	27H	;TMP PULSE-WIDTH COUNTER
TMPL	EQU	28H
BITC	EQU	29H	;BIT COUNTER

;RB7-> INSIDER PIN   RB6-> G0 PIN
#DEFINE X	PORTB,7		;PORT INSIDER
#DEFINE T	TRISB,7		;TRIS INSIDER

#DEFINE BR1	STATUS,RP0	;RegBank1 Sel

;MAIN VARS:
BKI	EQU	2CH	;LAST 80xBREAK POINTER (A0H-EFH)
BP	EQU	30H	;B0B1...BF -> BRK-GROUP-N VALID STATUS
S2	EQU	40H	;S2S3...S32S33 -> 40H-5FH ADR-VAR-RANGE
S	EQU	60H	;ADR-VAR COUNTER (SHOW CMD)
BRKN	EQU	61H	;BREAKPOINT NUMBER
DGN	EQU	62H	;SPEED MULTIPLIER (1x), 2x, 4x, 8x 16x
DASC	EQU	63H	;ASCII DISPLAY POINTER (50H-5FH)
CHAR	EQU	64H	;ASCII KEY INPUT
FLG	EQU	65H	;FLAGS-REG
FLG1	EQU	66H	;FLAGS-REG1
HSTART	EQU	67H	;START ADR-RANGE
LSTART	EQU	68H
HEND	EQU	69H	;END ADR-RANGE
LEND	EQU	6AH
I	EQU	6BH	;LOOP COUNTER
TMP	EQU	6CH	;TEMP VAL
K	EQU	6DH	;ADR RANGE COUNTER (DUMP CMD-BUFFER)
D0	EQU	6EH	;D0D1-D2D3-...D16D17 -> 6EH-7FH
D1	EQU	6FH	;L H  L H ....L  H 8xHLDigit INPUT
D2	EQU	70H
D3	EQU	71H

;CONST
BKS		EQU	0A0H	;A0-EF FIRST BREAK START BUFFER
BKE		EQU	0EFH	;A0-EF LAST BREAK END BUFFER
EE_OFFSET	EQU	0B0H	;CONSTANT OFFSET TO SAVE EECMD-BUFFER
				;K-D2D3-...D16D17 -> EEADR(1DH-2FH)
;MAIN FLAGS:
#DEFINE	F_DIG	FLG,0	;DIGIT IN FLAG
#DEFINE	F_CMD	FLG,1	;CMD IN FLAG
#DEFINE	F_HEX	FLG,2	;HEX DIGIT IN FLAG
#DEFINE	F_BRK	FLG,3	;IN BREAK FLAG
#DEFINE	F_EER	FLG,4	;EEDATA RD FLAG
#DEFINE	F_END	FLG,5	;FMEM END FLAG
#DEFINE	F_IN	FLG,6	;DATA-IN FLAG
#DEFINE	F_SM	FLG,7	;S CMD MANUAL/AUTO 1/0
#DEFINE	F_CF	FLG1,0	;CALLF-CMD  ON/OFF 1/0
#DEFINE	F_MCF	FLG1,1	;CALLF-MODE ON/OFF 1/0
#DEFINE	F_D6	FLG1,2	;6x DIGIT INPUT MODE D2D1D0
#DEFINE	F_GI	FLG1,3	;INITIAL SCAN MODE ON/OFF 0/1
#DEFINE	F_HE	FLG1,4	;PROMPT-ROUTINE SKIP CRLF-OUTPUT 
#DEFINE	F_MT	FLG1,5	;T-SUBCMD ON/OFF 1/0

#DEFINE	LRED	PORTA,1	;LED  RED  ON/OFF 1/0
#DEFINE	LGREEN	PORTA,0	;LED GREEN ON/OFF 1/0

;ASCII CONST

CR	EQU	0DH
LF	EQU	0AH
TAB	EQU	09H
BS	EQU	08H
BLANK	EQU	20H
ESC	EQU	1BH
EOT	EQU	04H

;********************************************************************

	ORG	00H

START	CLRF	TMPL		;START-UP DELAY
	DECFSZ	TMPL
	GOTO	$-1

	MOVLW	07H		;DIGITAL MODE RA0-3
	MOVWF	CMCON
	MOVLW	0FCH		;INIT PORTA-B LATCHES
	MOVWF	PORTA
	MOVLW	0FFH
	MOVWF	PORTB

	MOVLW	FLG
	CLRF	FLG1
	CLRF	FLG		;F_EER=0 (EEREAD NOT OFFSET)
	CALL	ER3		;FLG<-EE(FLG)
	MOVLW	80H		;SET BREAK OFF CONDITION
	ANDWF	INDF		;RESTORE F_SM (S CMD AUTO/MANUAL FLAG)

	MOVLW	90H
	MOVWF	RCSTA		;RX-EN
	MOVLW	HIGH TXT
	MOVWF	PCLATH		;SET TXT-AREA
	BSF	BR1		;SEL BR1
	MOVLW	25H
	MOVWF	TXSTA		;TX-EN, 8BIT, ASYNC, BRGH
	MOVLW	BAUD		;BRG -> PC BAUDRATE
	MOVWF	SPBRG
	MOVLW	0FCH		;RA7-2 IN, RA1-0 OUT
	MOVWF	TRISA
	MOVLW	0FBH		;RB7-3 IN, RB2 TX-OUT, RB1 RX-IN, RB0 IN
	MOVWF	TRISB
	BSF	EECON1,WREN	;ENABLE EEPROM WR
	CLRF	STATUS		;SEL RB0
	MOVLW	LOW ET0		;DISPLAY PWR STRING
	CALL	PROMPT
	CALL	LBRKG		;LOAD BRK-GROUP VALID STATUS

;********************************************************************
;********************************************************************

STRT1	MOVLW	BKS		;INIT LAST BREAK BUFFER
	MOVWF	BKI
	MOVWF	FSR
STRT2	CLRF	INDF
	INCF	FSR
	MOVLW	BKE+1
	XORWF	FSR,W
	BTFSS	STATUS,Z
	GOTO	STRT2

MAIN	MOVLW	LOW ET1		;SHOW MAIN PROMPT
	CALL	PROMPT

	BCF	F_EER		;CLEAR F_ERR (E CMD)
	BCF	F_DIG		;RESET DIGIT IN FLAG
	BSF	F_CMD		;SET CMD INPUT ONLY
	CALL	KEYIN		;WAIT CMD KEY INPUT

	BTFSS	F_IN		;F_IN=1?
	GOTO	MAIN1		;N, CONTINUE
	BCF	F_IN		;Y, FROM BREAK
	MOVLW	'N'
	XORWF	CHAR,W		;KEYIN N?
	BTFSC	STATUS,Z	;N, CONTINUE
	GOTO	G02		;Y, BREAK-RET

MAIN1	MOVF	CHAR,W		;PARSER CMD
	XORLW	'H'
	BTFSC	STATUS,Z
	GOTO	HELP		;H -> HELP CMD
	XORLW	'S'^'H'
	BTFSC	STATUS,Z
	GOTO	SHOW		;S -> SHOW CMD
	XORLW	'G'^'S'
	BTFSC	STATUS,Z
	GOTO	GO		;G -> GO CMD
	XORLW	'V'^'G'
	BTFSC	STATUS,Z
	GOTO	VBRK		;V -> VBRK CMD
	XORLW	'X'^'V'
	BTFSC	STATUS,Z
	GOTO	XBRK		;X -> XBRK CMD
	XORLW	'T'^'X'
	BTFSC	STATUS,Z
	GOTO	TBRK		;T -> TBRK CMD
	XORLW	'I'^'T'
	BTFSC	STATUS,Z
	GOTO	INP		;I -> INIT PULSE CMD

	BTFSS	F_BRK		;BREAK CONDITION?
	GOTO	MAIN		;N, RESCAN CMD

	XORLW	'C'^'I'
	BTFSC	STATUS,Z
	GOTO	CALLF		;C -> CALL FUNCTION CMD
	XORLW	'R'^'C'
	BTFSC	STATUS,Z
	GOTO	READ		;R -> READ CMD
	XORLW	'W'^'R'
	BTFSC	STATUS,Z
	GOTO	WRITE		;W -> WRITE CMD
	XORLW	'D'^'W'
	BTFSC	STATUS,Z
	GOTO	DUMP		;D -> DUMP CMD
	XORLW	'F'^'D'
	BTFSC	STATUS,Z
	GOTO	FMEM		;F -> FMEM CMD
	XORLW	'B'^'F'
	BTFSC	STATUS,Z
	GOTO	BREAK		;B -> BREAK CMD
	XORLW	'E'^'B'
	BTFSS	STATUS,Z
	GOTO	MAIN
				;E -> EEPROM DUMP CMD

;******** EDUMP CMD	(ON-BREAK)
; EEPROM DATA READ CMD: E sss.fff sss.fff  (UP TO 4)
		
EDUMP	BSF	F_EER		;SET EEDATA SPACE

;******** DUMP CMD	(ON-BREAK)
; DISPLAY DATA RANGES: D sss.fff sss.fff  (UP TO 4x sss.fff)
; AND SAVE IN EEPROM LAST RANGES USED
; IF EXIST.. FIRST SHOW: D(sss.fff sss.fff..).
; IF PRESS (CR). EXECUTE BASED ON THE LAST USED RANGES.
; IF INPUT NEW.. SAVE NEW RANGES IN EEPROM

DUMP	MOVLW	K		;W <- ADR(K)  RANGES NUMBER
	CALL	ER3		;READ ACTUAL K FROM EEPROM
	MOVWF	I		;K->I

	BTFSC	STATUS,Z	;K=0?
	GOTO	DM2		;Y, OUT
	SUBLW	4
	BTFSC	STATUS,C	;K>4?
	GOTO	DM9		;N, CONT
	CLRF	K		;Y, K=0
	GOTO	DM2		;OUT

DM9	CLRC		;IF 1-K-4, DISPLAY ACTUAL RANGE
	RLF	I,W
	MOVWF	TMP
	RLF	TMP,W
	ADDLW	D1		;FSR=ADR(D1)+K*4
	MOVWF	FSR

DM1	CALL	OUTS		;DISPLAY ACTUAL RANGE
	CALL	ER1
	CALL	LAOUT		;DISPLAY HLsss.HLfff RANGE(I)
	DECF	FSR
	CALL	ER1
	CALL	AOUT
	MOVLW	'.'
	CALL	DOUT
	DECF	FSR
	CALL	ER1
	CALL	LAOUT
	DECF	FSR
	CALL	ER1
	CALL	AOUT
	DECF	FSR
	DECFSZ	I		;DISPLAY ALL RANGES
	GOTO	DM1

	MOVLW	'?'		;DISPLAY NEW RANGE INPUT
	CALL	DOUT
	CALL	CRLF
	CALL	OUT4S
	MOVLW	'D'
	BTFSC	F_EER
	MOVLW	'E'
	CALL	DOUT

DM2	CALL	OUTS
	CLRF	I		;RESET FIELD nnn COUNTER
DM3	MOVLW	8
	XORWF	I,W
	BTFSC	STATUS,Z	;I->8?
	GOTO	DM7		;Y, OUT, 4 RANGES COMPLETE
	CALL	INPUT		;N, WAIT DIGIT INPUT
	BTFSS	F_DIG		;DIGIT?
	GOTO	DM5		;N, OUT AND VERIFY CMD

	MOVLW	0FH
	ANDWF	D1
	MOVLW	.16
	MOVWF	TMP		;MOVE DIGIT BUFFER
DM4	MOVLW	D0-1
	ADDWF	TMP,W
	MOVWF	FSR		;FSR<-TMP+ADR(D0-1)
	MOVF	INDF,W
	INCF	FSR		;D0D1->D2D3->..D16D17
	INCF	FSR
	MOVWF	INDF
	DECFSZ	TMP
	GOTO	DM4

	INCF	I		;NEXT FIELD
DM5	BTFSS	I,0		;EVEN FIELD?
	GOTO	DM6		;Y, CHECK END RANGE
	MOVLW	'.'		;N, CHECK FIELD SEP
	XORWF	CHAR,W
	BTFSC	STATUS,Z	;SEP='.'?
	GOTO	DM3		;Y, CONTINUE DIGIT INPUT
	GOTO 	ABORT		;N, ERROR, END CMD

DM6	MOVF	CHAR,W		;CHECK RANGE SEP
	XORLW	BLANK
	BTFSC	STATUS,Z	;SEP=BLANK?
	GOTO	DM3		;Y, CONTINUE DIGIT INPUT
	XORLW	CR^BLANK	;CHECK RANGE END
	BTFSS	STATUS,Z	;END RANGE?
	GOTO	ABORT		;N, ERROR, END CMD
	MOVF	I,W
	BTFSS	STATUS,Z	;FIELDS COUNTER=0?
	GOTO	DM7		;N, SAVE NEW RANGES
	MOVF	K,W
	BTFSC	STATUS,Z	;EXISTING RANGES COUNTER=0?
	GOTO	MAIN		;Y, GO MAIN, NOTHING TO DO
	MOVLW	1BH		;N, 1 LINE UP
	CALL	DOUT
	MOVLW	5BH
	CALL	DOUT
	MOVLW	41H
	CALL	DOUT
	GOTO	SDUMP		;DISPLAY RANGES

DM7	MOVLW	K		;FSR<-ADR(K)
	MOVWF	FSR
	CLRC
	RRF	I,W		;I(FIELD COUNTER)/2= RANGE COUNTER
	MOVWF	INDF
	CALL	EW1		;SAVE NEW K -> EE(K)
	RLF	I		;I(FIELD COUNTER)*2= DIGIT COUNTER
	MOVLW	D1
	MOVWF	FSR		;FSR<- ADR(D1)
DM8	INCF	FSR
	CALL	EW1		;(FSR)->EE(FSR)
	DECFSZ	I		;SAVE NEW RANGE DIGITS IN EEPROM
	GOTO	DM8

SDUMP	CALL	OUT5S		;INIT DISPLAY RANGE ADR
	CLRF	I
DS1	MOVF	I,W
	CALL	LAOUT		;DISPLAY DUMP HEADER
	CALL	OUT2S
	INCF	I
	MOVF	I,W
	CALL	MIDCHK
	MOVLW	10H
	XORWF	I,W
	BTFSS	STATUS,Z
	GOTO	DS1

DS2	MOVF	K,W		;I<-K*4
	MOVWF	I
	CLRC
	RLF	I
	RLF	I
	MOVLW	D1
	ADDWF	I,W
	MOVWF	FSR		;FSR<-I+ADR(D1)
	MOVF	INDF,W
	MOVWF	HSTART		;READ START FIELD OF RANGE(K)
	DECF	FSR
	MOVF	INDF,W
	MOVWF	LSTART
	DECF	FSR
	MOVF	INDF,W
	MOVWF	HEND		;READ END FIELD OF RANGE(K)
	DECF	FSR
	MOVF	INDF,W
	MOVWF	LEND

	MOVF	LSTART,W	;CHECK VALID RANGE
	SUBWF	LEND,W
	MOVF	HSTART,W
	BTFSS	STATUS,C
	INCFSZ	HSTART,W
	SUBWF	HEND,W
	BTFSC	STATUS,C	;START < END?
	GOTO	NEWL		;Y, DISPLAY NEW LINE
	MOVF	LSTART,W	;N, START->END
	MOVWF	LEND
	MOVF	HSTART,W
	MOVWF	HEND

NEWL	CALL	CRLF		;NEW LINE
	MOVLW	S2		;POINTER TO ASCII BUFFER
	MOVWF	DASC		;INICIT ASCII BUFFER
	MOVF	HSTART,W
	CALL	LAOUT		;DISPLAY ROW ADR
	MOVLW	0F0H
	ANDWF	LSTART,W
	MOVWF	I
	CALL	AOUT
	CALL	OUT2S

	BTFSC	PIR1,RCIF	;CHECK STOP VIA ANY KEY IN
	GOTO	MAIN

SPC	MOVF	I,W		;FILL WITH '-' UNTIL FIRST START
	XORWF	LSTART,W
	BTFSC	STATUS,Z
	GOTO	MORE
	MOVLW	'-'
	CALL	DOUT
	CALL	OUT2S
	MOVLW	'.'
	CALL	SASCII
	INCF	I
	MOVF	I,W
	CALL	MIDCHK
	GOTO	SPC

MORE	MOVLW	0FH		;DISPLAY RANGE DATA
	ANDWF	HSTART,W	;BUILD RD TARGET CMD
	BTFSC	F_EER
	IORLW	30H		;IF EEDATA
	CALL	TXINS
	MOVF	LSTART,W
	CALL	TXINS
	CALL	RXINS		;READ DATA FROM TARGET
	MOVF	DB0,W
	CALL	SASCII		;SAVE ASCII(DATA) ON ASCII BUFFER
	CALL	AOUT		;DISPLAY 2xASCII HEX DATA
	CALL	OUTS

	MOVF	LEND,W		;CHK START=END
	SUBWF	LSTART,W
	MOVF	HEND,W
	BTFSS	STATUS,C
	INCFSZ	HEND,W
	SUBWF	HSTART,W
	BTFSS	STATUS,C	;START=END?
	GOTO	LINE		;N, CONTINUE LINE
DS3	INCF	LSTART		;Y, END RANGE
	MOVF	LSTART,W
	CALL	MIDCHK
	MOVLW	0FH
	ANDWF	LSTART,W
	BTFSC	STATUS,Z
	GOTO	DS4
	MOVLW	'-'
	CALL	DOUT
	CALL	OUT2S		;COMPLETE LAST LINE
	MOVLW	'.'
	CALL	SASCII
	GOTO	DS3
DS4	CALL	DASCII		;DISPLAY SAME LINE IN ASCII
	CALL	CRLF
	DECFSZ	K		;LAST RANGE?
	GOTO	DS2		;N, NEXT RANGE
	GOTO	MAIN		;Y, END CMD

LINE	INCF	LSTART		;LINE FORWARD
	BTFSC	STATUS,Z
	INCF	HSTART
	MOVF	LSTART,W
	CALL	MIDCHK
	MOVLW	0FH
	ANDWF	LSTART,W
	BTFSS	STATUS,Z	;END OF LINE?
	GOTO	MORE		;N, NEXT ADR
	CALL	DASCII		;Y, DISPLAY EQUIVALENT ASCII
	GOTO	NEWL		;GO TO NEXT LINE

DASCII	CALL	OUT4S		;DISPLAY ASCII FROM HEX LINE
	MOVLW	S2		;POINTER TO BUFFER ASCII
	MOVWF	FSR
	SUBWF	DASC		;ASCII COUNTER

DS5	MOVF	INDF,W		;SHOW '.' IF ASCII = 0FFH or 7FH
	ANDLW	7FH
	XORLW	7FH
	BTFSC	STATUS,Z
	GOTO	DS6
	MOVLW	20H
	SUBWF	INDF,W
	MOVF	INDF,W
	BTFSS	STATUS,C
DS6	MOVLW	'.'		;SHOW '.' IF ASCII < 20H
	CALL	DOUT
	INCF	FSR
	MOVF	FSR,W
	CALL	MIDCHK
	DECFSZ	DASC		;SHOW COMPLETE BUFFER ASCII
	GOTO	DS5
	RETURN

SASCII	MOVWF	TMP		;ASCII SAVE TO BUFFER ROUTINE
	MOVF	DASC,W
	INCF	DASC
	MOVWF	FSR
	MOVF	TMP,W
	MOVWF	INDF
	RETURN

MIDCHK	ANDLW	0FH		;CHECK MID ADR (08) PLACE ROUTINE
	XORLW	08H
	BTFSC	STATUS,Z
	GOTO	OUTS
	RETURN

;******** SHOW CMD
; SHOW DATA VARIABLES: S nnn nnn   nnn (UP TO 16x nnn)
; AND SAVE IN EEPROM THE LAST ADDRESS USED
; IF ST(CR) -- TOGGLE AUTO ON/OFF FLAG F_SM 0/1
; IF  S(CR) -- (OFF BREAK) SHOW VARIABLES ADDRESS
; IF  S(CR) -- (ON  BREAK) SHOW VARIABLES ADDRESS + DATA
; IF S nnn nnn...nnn (CR) - ONLY SAVE VARIABLES ADDRESS
; IF S+nnn nnn...nnn (CR) - ONLY ADD+ SAVE VARS ADDRESS

SHOW	CLRF	I		;INIT VAR COUNTER
SH1	CALL	INPUT		;WAIT VAR-ADR DIGIT
	BTFSS	F_DIG		;DIGIT IN?
	GOTO	SH3		;N, VERIFY END INPUT

	MOVLW	.30		;Y, MOVE DIGIT BUFFER
	MOVWF	TMP
SH2	MOVLW	S2-1
	ADDWF	TMP,W
	MOVWF	FSR		;FSR<-TMP+ADR(S2-1)
	MOVF	INDF,W
	INCF	FSR		;D0D1->S2S3->..S32S33
	INCF	FSR
	MOVWF	INDF
	DECFSZ	TMP
	GOTO	SH2

	DECF	FSR
	MOVLW	0FH
	ANDWF	D1,W
	MOVWF	INDF
	MOVF	D0,W
	MOVWF	S2
	INCF	I		;NEXT VAR-ADR

SH3	MOVLW	BLANK
	XORWF	CHAR,W
	BTFSC	STATUS,Z	;BLANK SEP?
	GOTO	SH1		;Y, CONTINUE

	MOVF	I,W
	BTFSS	STATUS,Z	;I=0?
	GOTO	SH4		;N, CHECK CR

	MOVLW	'T'
	XORWF	CHAR,W
	BTFSC	STATUS,Z	;T?
	GOTO	SH11		;Y, TOGGLE F_SM

	XORLW	'+'^'T'
	BTFSS	STATUS,Z	;+?
	GOTO	SH4		;N, CHECK CR

	MOVLW	S		;Y, ADD VARS
	CALL	ER3
	BTFSC	STATUS,Z	;S=0?
	GOTO	SHOW		;Y, NEW VARS
	ADDLW	100H-.16
	BTFSC	STATUS,C	;S=16?
	GOTO	MAIN		;Y, NOTHING TO ADD

	MOVLW	.32		;READ FORMER VARS
	MOVWF	I
SH3A	DECF	FSR
	CALL	ER1
	DECFSZ	I
	GOTO	SH3A
	MOVF	S,W
	MOVWF	I
	GOTO	SH1		;CONTINUE ADDING VARS

SH4	MOVLW	CR
	XORWF	CHAR,W
	BTFSS	STATUS,Z	;END CMD?
	GOTO	ABORT		;N, ERROR CMD

	MOVF	I,W
	BTFSC	STATUS,Z	;VAR-ADR COUNTER=0?
	GOTO	SH6		;Y, CHK LAST VAR-ADR

	SUBLW	.16
	MOVF	I,W
	BTFSS	STATUS,C	;I>16?
	MOVLW	.16		;Y, LIMIT I=16
	MOVWF	S
	MOVLW	S
	MOVWF	FSR		;FSR<-ADR(S)
	MOVLW	33		;ADR-BYTES TO TRANSFER
	MOVWF	I
SH5	CALL	EW1		;SAVE TO EEPROM S2S3..S33
	DECF	FSR
	DECFSZ	I
	GOTO	SH5
	GOTO	MAIN		;END CMD

SH6	MOVLW	S		;FSR<-ADR(S)
	CALL	ER3		;S<-EE(S)
	BTFSC	STATUS,Z	;S=0?
	GOTO	MAIN		;Y, END CMD
	SUBLW	.16
	BTFSS	STATUS,C	;S>16?
	GOTO	MAIN		;Y, END CMD

	CLRC			;N, SHOW ADR
	RLF	S,W		;S*2=ADR-DIGITS
	ADDLW	S2-1
	MOVWF	FSR		;FSR<-ADR(S2)-1+S*2
	CLRF	I		;ADR-LINE COUNTER
	GOTO	SH8

SH7	CALL	OUTS		;N, 2-SPACE SEP

SH8	CALL	OUTS
	CALL	ER1		;READ H-DIGIT-ADR
	MOVWF	HSTART
	CALL	LAOUT		;SHOW H-ADR-DIGIT
	DECF	FSR
	CALL	ER1		;READ L-DIGIT-ADR
	MOVWF	LSTART
	CALL	AOUT		;SHOW L-ADR-DIGIT
	BTFSS	F_BRK		;ON-BREAK?
	GOTO	SH9		;N, SKIP DATA

	MOVLW	':'		;Y, SHOW DATA
	CALL	DOUT
	MOVLW	0FH
	ANDWF	HSTART,W
	CALL	TXINS		;BUILD RD TARGET CMD
	MOVF	LSTART,W
	CALL	TXINS
	CALL	RXINS		;READ DATA FROM TARGET
	MOVF	DB0,W
	MOVWF	INDF		;SAVE TARGET DATA TO SBIN
	CALL	AOUT		;SHOW TARGET DATA
	CALL	OUTS
	CALL	ADB0		;SHOW TARGET DATA ASCII

	INCF	I
SH9	DECF	FSR
	DECFSZ	S		;LAST LINE?
	GOTO	SH10		;N, CONT
	BTFSC	F_BRK		;Y, ON-BREAK?
	CALL	SHBIN		;Y, SHOW LAST BIN LINE
	GOTO	MCRLF		;N, END CMD

SH10	BTFSS	F_BRK		;ON-BREAK?
	GOTO	SH7		;N, SHOW NEXT ADR
	MOVF	I,W		;Y, CONT
	XORLW	8
	BTFSS	STATUS,Z	;LINE END?
	GOTO	SH7		;N, CONT
	CALL	SHBIN		;Y, SHOW BIN LINE
	CALL	CRLF
	CALL	CRLF
	GOTO	SH8

SH11	MOVLW	LOW ETB		;SHOW AUTO PROMPT
	CALL	PROMPT	
	BTFSC	F_SM		;F_M=0?
	GOTO	SH12
	BSF	F_SM		;Y, F_SM->1
	MOVLW	'F'		;SHOW AUTO-OFF
	CALL	DOUT
	GOTO	SH13
SH12	BCF	F_SM		;N, F_SM->0
	MOVLW	'N'		;SHOW AUTO-ON
SH13	CALL	DOUT
	MOVLW	FLG
	MOVWF	FSR		;SAVE F_SM->EEPROM
	CALL	EW1
	GOTO	MAIN

;******** READ CMD	(ON-BREAK)
; READ DATA VARIABLES:
; R  nnn nnn   nnn(CR) (UP TO 8x nnn) SHOWS DATA IN HEX AND BINARY THEN END.
; RT nnn nnn   nnn(CR) STARTS (SPACE: START/STOP) CONTINUOUS DISPLAY, ANY KEY END

READ	BCF	F_MT		;RESET T-SUBCMD
	CLRF	K		;INIT DIGIT COUNT

RD1	CALL	INPUT		;WAIT ADR
	BTFSS	F_DIG		;DIGIT IN?
	GOTO	RD3		;N, VERIFY END INPUT

	MOVLW	0FH		;Y, MOVE DIGIT BUFFER
	ANDWF	D1
	MOVLW	.16
	MOVWF	TMP
RD2	MOVLW	D0-1
	ADDWF	TMP,W
	MOVWF	FSR		;FSR<-TMP+ADR(D0-1)
	MOVF	INDF,W
	INCF	FSR		;D0D1->D2D3->..D16D17
	INCF	FSR
	MOVWF	INDF
	DECFSZ	TMP
	GOTO	RD2

	INCF	K		;NEXT ADR
	MOVF	K,W		;LIMIT K>8
	SUBLW	8
	MOVLW	8
	BTFSS	STATUS,C
	MOVWF	K

RD3	MOVLW	BLANK
	XORWF	CHAR,W
	BTFSC	STATUS,Z	;ADR SEP?
	GOTO	RD1		;Y, NEXT VAR-ADR
	MOVF	K,W
	BTFSS	STATUS,Z	;ADR-COUNTER=0?
	GOTO	RD4		;N, CONT
	MOVLW	'T'
	XORWF	CHAR,W
	BTFSS	STATUS,Z	;T-MODE?
	GOTO	RD4		;N, CONT
	BSF	F_MT		;Y, SET T-MODE
	GOTO	RD1		;NEXT VAR-ADR
RD4	MOVLW	CR
	XORWF	CHAR,W
	BTFSS	STATUS,Z	;END CMD?
	GOTO	ABORT		;N, ERROR CMD
	MOVF	K,W
	BTFSC	STATUS,Z	;ADR-COUNTER=0?
	GOTO	MAIN		;Y, END CMD
	CALL	CRLF		;N, SHOW READ DATA

RD5	CALL	SREAD
	BTFSS	F_MT		;T-SUBCMD?
	GOTO	MCRLF		;N, END CMD

	BTFSS	PIR1,RCIF	;ANY KEY PRESSED?
	GOTO	RD8		;N, READING LOOP
	MOVF	RCREG,W		;Y, READ CHAR
	XORLW	BLANK
	BTFSS	STATUS,Z	;KEY = BLANK?
	GOTO	MCRLF		;N, END CMD

	BTFSS	PIR1,RCIF	;Y, STOP READING
	GOTO	$-1		;WAIT KEY
	MOVF	RCREG,W		;READ CHAR
	XORLW	BLANK
	BTFSS	STATUS,Z	;KEY = BLANK?
	GOTO	MCRLF		;N, END CMD

RD8	MOVLW	CR		;Y, CONTINUE READING
	CALL	DOUT		;BACK
	MOVLW	1BH		;AND 1 LINE UP
	CALL	DOUT
	MOVLW	5BH
	CALL	DOUT
	MOVLW	41H
	CALL	DOUT
	GOTO	RD5		;SHOW READ DATA AGAIN

SREAD	MOVF	K,W
	MOVWF	S		;DATA VAR COUNTER
	MOVWF	I		;BIN  VAR COUNTER
	ADDWF	I,W		;I*2= DIGIT COUNTER
	ADDLW	D1
	MOVWF	FSR		;FSR<-ADR(D1)+I*2
	GOTO	$+2		;START 1-SPACE

RD6	CALL	OUTS
	CALL	OUTS
	MOVF	INDF,W
	DECF	FSR
	ANDLW	0FH		;BUILD TARGET READ CMD
	MOVWF	DB0
	CALL	LAOUT		;SHOW H-ADR
	CALL	TXINS+1
	MOVF	INDF,W
	MOVWF	DB0
	CALL	AOUT		;SHOW L-ADR
	CALL	TXINS+1
	CALL	RXINS		;WAIT DATA FROM TARGET
	MOVLW	':'
	CALL	DOUT

	MOVF	DB0,W
	BCF	FSR,5		;SAVE DATA AT 50-5F
	MOVWF	INDF
	BSF	FSR,5
	CALL	AOUT		;SHOW READ DATA
	CALL	OUTS
	CALL	ADB0		;SHOW DB0 ASCII

	DECF	FSR
	DECFSZ	S		;LAST ADR?
	GOTO	RD6		;N, CONT
	BCF	FSR,5		;POINT TO SAVED DATA

SHBIN	CALL	CRLF		;Y, SHOW DATA BIN
	CLRC
	RLF	I,W		;I= #VARS IN A LINE
	ADDWF	FSR		;FSR <- FSR+Ix2
	GOTO	$+2

RD7	CALL	OUTS		;SHOW DATA BIN-LINE
	CALL	OUTS
	DECF	FSR
	MOVF	INDF,W
	MOVWF	DB0
	CALL	SBIN
	DECF	FSR
	DECFSZ	I
	GOTO	RD7
	RETURN

;******** WRITE CMD	(ON-BREAK)
; WRITE DATA: W nnn dd
; (CR)  IF DATA, WRITE DATA dd ON nnn AND END
; (SP)  IF DATA, WRITE DATA dd ON nnn, SHOW nnn AND WAIT dd
; (+/-) IF DATA, WRITE dd ON nnn, INC/DEC nnn, SHOW nnn AND WAIT dd
;
; WRITE DATA ARRAY: WT nnn dd dd  dd (UP TO 16x dd)
; (CR)  IF DATA, WRITE dd dd  dd SEQUENCE ON nnn (BS/SPACE -> +/- STEP)

WRITE	BCF	F_MT		;RESET T-SUBCMD
	CLRF	I		;INIT WRITE COUNT
	CALL	INPUT		;WAIT ADR OR 'T'
	BTFSC	F_DIG		;DIGIT IN?
	GOTO	WR3		;Y, SAVE ADR D1D0->D3D2
	MOVLW	'T'
	XORWF	CHAR,W
	BTFSS	STATUS,Z	;T?
	GOTO	WR2		;N, WAIT ADR-INPUT
	BSF	F_MT		;Y, SET T-MODE

WR1	CALL	INPUT		;WAIT ADR
	BTFSC	F_DIG		;DIGIT IN?
	GOTO	WR3		;Y, SAVE ADR D1D0->D3D2
WR2	MOVLW	BLANK		;N, CHECK SPACE
	XORWF	CHAR,W
	BTFSS	STATUS,Z	;SPACE?
	GOTO	ABORT		;N, ABORT CMD
	GOTO	WR1		;Y, WAIT ADR-INPUT

WR3	MOVLW	0FH
	ANDWF	D1,W
	MOVWF	D3		;D1->D3 H-ADR
	MOVWF	HEND		;->HEND
	MOVF	D0,W
	MOVWF	D2		;D0->D2 L-ADR
	MOVWF	LEND		;->LEND

	MOVLW	BLANK
	XORWF	CHAR,W
	BTFSS	STATUS,Z	;SPACE?
	GOTO	ABORT		;N, ABORT CMD
	MOVLW	BS
	CALL	DOUT

	BTFSC	F_MT		;T-MODE?
	GOTO	WT1		;Y, T-SUBCMD

WR4	MOVLW	':'		;SHOW ADR SEP
	CALL	DOUT
	CALL	INPUT		;WAIT DATA
	MOVLW	'+'
	XORWF	CHAR,W
	BTFSS	STATUS,Z	;'+'?
	GOTO	WR6		;N, CONTINUE
	CALL	SWRITE		;IF DATA, WRITE
	INCF	D2		;AND INC WRITE-ADR
	BTFSC	STATUS,Z
	INCF	D3
WR5	MOVLW	03		;SHOW 4xWRITES PER LINE
	ANDWF	I,W
	XORLW	03
	BTFSC	STATUS,Z
	CALL	CRLF
	INCF	I
	CALL	OUT4S		;SHOW NEXT WRITE ADR
	MOVF	D3,W
	CALL	LAOUT
	MOVF	D2,W
	CALL	AOUT
	GOTO	WR4		;NEXT DATA INPUT
WR6	MOVLW	'-'
	XORWF	CHAR,W
	BTFSS	STATUS,Z	;'-'?
	GOTO	WR7		;N, CONTINUE
	CALL	SWRITE		;IF DATA, WRITE
	MOVLW	1		;AND DEC WRITE-ADR
	SUBWF	D2
	BTFSS	STATUS,C
	DECF	D3
	GOTO	WR5		;SHOW NEXT WRITE ADR

WR7	MOVLW	BLANK
	XORWF	CHAR,W
	BTFSS	STATUS,Z	;NEXT?
	GOTO	WR8		;N, CONTINUE
	CALL	SWRITE		;IF DATA, WRITE
	GOTO	WR5		;AND SHOW WR-ADR

WR8	MOVLW	CR
	XORWF	CHAR,W
	BTFSS	STATUS,Z	;CR?
	GOTO	ABORT		;N, ERROR CMD
	CALL	SWRITE		;IF DATA, WRITE
	GOTO	MAIN		;AND ENDS CMD

WT1	MOVLW	':'		;PROMPT FOR DATA INPUT
	CALL	DOUT
	CALL	OUTS

	CALL	INX16		;INPUT UP TO 16x dd

	XORLW	CR^BLANK
	BTFSS	STATUS,Z	;CHAR= CR?
	GOTO	ABORT		;N, CMD ERROR

	MOVF	S,W
	BTFSC	STATUS,Z	;DATA IN?
	GOTO	MAIN		;N, END CMD
	SUBLW	.16
	MOVLW	.16
	BTFSS	STATUS,C	;DATA COUNT > 16?
	MOVWF	S		;Y, S=16

	CALL	CRLF		;SHOW ADR POINTED
	MOVF	HEND,W
	CALL	LAOUT
	MOVF	LEND,W
	CALL	AOUT
	MOVLW	':'
	CALL	DOUT
	CALL	OUTS

	MOVLW	40H		;BUILD TARGET WR CMD
	IORWF	HEND

	MOVLW	D1		;POINT TO FIRST DATA
	ADDWF	S,W
	MOVWF	FSR
	MOVWF	D0		;COPY OF FIRST DATA ADR

WT2	MOVF	INDF,W		;SHOW DATA TO WRITE
	CALL	AOUT
	MOVF	HEND,W		;SEND TARGET WR CMD
	CALL	TXINS
	MOVF	LEND,W
	CALL	TXINS
	MOVF	INDF,W
	CALL	TXINS

	BTFSS	PIR1,RCIF	;ANY KEY PRESSED?
	GOTO	$-1		;N, WAIT
	MOVF	RCREG,W		;Y, READ CHAR

	XORLW	BLANK
	BTFSS	STATUS,Z	;KEY = SPACE?
	GOTO	WT3		;N, CHECK BACK
	DECF	FSR		;POINT NEXT DATA
	MOVF	FSR,W
	SUBLW	D1
	MOVF	D0,W
	BTFSC	STATUS,C	;LAST DATA = LAST?
	MOVWF	FSR		;Y, POINT TO FIRST
	GOTO	WT4
WT3	XORLW	BS^BLANK
	BTFSS	STATUS,Z	;KEY = BACK SPACE?
	GOTO	MCRLF		;N, END CMD
	INCF	FSR
	MOVF	FSR,W
	SUBWF	D0,W
	MOVLW	D2
	BTFSS	STATUS,C	;LAST DATA = FIRST?
	MOVWF	FSR		;Y, POINT TO LAST
WT4	MOVLW	BS
	CALL	DOUT
	CALL	DOUT
	GOTO	WT2		;N, LOOP NEXT DATA

SWRITE	BTFSS	F_DIG		;DIGIT IN?
	RETURN			;N, RETURN
	MOVF	D3,W
	ANDLW	0FH		;BUILD TARGET WR CMD
	IORLW	40H
	CALL	TXINS
	MOVF	D2,W
	CALL	TXINS		;WR CMD L-ADR
	MOVF	D0,W
	CALL	TXINS		;WR CMD DATA
	RETURN

;******** FMEM CMD	(ON-BREAK)
; FILL MEMORY:
; F sss.fff dd dd  dd(CR).. WRITE dd dd  dd (UP TO 16x dd) FROM sss TO fff
; F sss dd dd dd   dd(CR).. WRITE dd dd  dd (UP TO 16x dd) FROM sss UP TO LAST dd

FMEM	BCF	F_END		;CLEAR END ADR FLAG
FM1	CALL	INPUT		;WAIT sss fff ADR
	BTFSC	F_DIG		;IN DIGIT?
	GOTO	FM2		;Y, SAVE ADR
	MOVLW	BLANK
	XORWF	CHAR,W
	BTFSC	STATUS,Z	;SPACE?
	GOTO	FM1		;Y, WAIT ADR
	GOTO	ABORT		;N, CMD ERROR
FM2	MOVLW	0FH
	ANDWF	D1,W
	MOVWF	HEND		;SAVE ADR
	MOVF	D0,W
	MOVWF	LEND
	BTFSC	F_END		;INPUT END ADR?
	GOTO	FM3		;Y, INPUT DATA
	MOVLW	'.'
	XORWF	CHAR,W
	BTFSS	STATUS,Z	;'.' ADR SEP?
	GOTO	FM3		;N, START ONLY
	BSF	F_END		;Y, SAVE START
	MOVLW	0FH
	ANDWF	D1,W		;WAIT END ADR INPUT
	MOVWF	HSTART
	MOVF	D0,W
	MOVWF	LSTART
	GOTO	FM1
FM3	MOVLW	BLANK
	XORWF	CHAR,W
	BTFSS	STATUS,Z	;DATA SEP?
	GOTO	ABORT		;N, CMD ERROR

	CALL	INX16		;Y, INPUT UP TO 16x dd

	XORLW	CR^BLANK
	BTFSS	STATUS,Z	;END CMD?
	GOTO	ABORT		;N, CMD ERROR
	MOVF	S,W
	BTFSC	STATUS,Z	;DATA IN?
	GOTO	MAIN		;N, END CMD
	SUBLW	.16
	MOVLW	.16
	BTFSS	STATUS,C	;DATA COUNT > 16?
	MOVWF	S		;Y, S=16
	BTFSC	F_END		;END ADR?
	GOTO	FM6		;Y, CHECK END<START
	MOVF	HEND,W		;N, SET START
	MOVWF	HSTART		;SET END=START+S-1
	MOVF	LEND,W
	MOVWF	LSTART
	DECF	S,W
	ADDWF	LEND
	BTFSC	STATUS,C
	INCF	HEND
	GOTO	FM7
FM6	MOVF	LSTART,W
	SUBWF	LEND,W
	MOVF	HSTART,W
	BTFSS	STATUS,C
	INCFSZ	HSTART,W
	SUBWF	HEND,W
	BTFSS	STATUS,C	;HLEND < HLSTART?
	GOTO	ABORT		;Y, CMD ERROR

FM7	MOVF	S,W
	MOVWF	I
	ADDLW	D1
	MOVWF	FSR		;FSR<-ADR(D1)+S
FM8	MOVF	HSTART,W
	ANDLW	0FH		;BUILD TARGET WR CMD
	IORLW	40H
	CALL	TXINS
	MOVF	LSTART,W
	CALL	TXINS		;WR CMD L-ADR
	MOVF	INDF,W
	CALL	TXINS		;WR CMD DATA
	DECF	FSR
	INCF	LSTART
	BTFSC	STATUS,Z
	INCF	HSTART
	MOVF	LSTART,W
	SUBWF	LEND,W
	MOVF	HSTART,W
	BTFSS	STATUS,C
	INCFSZ	HSTART,W
	SUBWF	HEND,W
	BTFSS	STATUS,C	;HLEND < HLSTART?
	GOTO	MAIN		;Y, ENDS CMD
	DECFSZ	I		;N, NEXT DATA
	GOTO	FM8
	GOTO	FM7

;******** BREAK CMD	(ON-BREAK)
; BREAKPOINT CMD:
; B (CR) - SHOWS BREAKPOINT nn - W_TMP - STATUS_TMP - OSC_FREQ
; BW/S dd (CR) - WRITE dd ON W/STATUS_TMP

BREAK	BSF	F_CMD		;WAIT CMD INPUT
BK1	CALL	KEYIN
	MOVLW	BLANK
	XORWF	CHAR,W
	BTFSC	STATUS,Z	;SPACE?
	GOTO	BK1		;Y, WAIT CMD INPUT
	BCF	CHAR,5		;UPPER CASE
	MOVLW	'W'
	XORWF	CHAR,W
	MOVLW	50H
	BTFSC	STATUS,Z	;W?
	GOTO 	BK5		;Y, W_TEMP RD/WR CMD
	MOVLW	'S'
	XORWF	CHAR,W
	MOVLW	60H
	BTFSC	STATUS,Z	;S?
	GOTO	BK5		;Y, STATUS_TEMP RD/WR CMD
	MOVLW	CR
	XORWF	CHAR,W
	BTFSS	STATUS,Z	;CR?
	GOTO	ABORT		;N, CMD ERROR

	MOVF	BKI,W		;Y, SHOW LAST BREAKS
	MOVWF	FSR		;FROM BKN-80 TO BKN
	MOVLW	4
	MOVWF	HEND
BK2	MOVLW	.20
	MOVWF	LEND		;SHOW 20xBRK IN 4 LINES
	CALL	CRLF
BK3	CALL	OUT2S
	MOVF	INDF,W
	CALL	AOUT
	INCF	FSR
	MOVLW	BKE+1
	XORWF	FSR,W		;END BUFFER?
	MOVLW	BKS
	BTFSC	STATUS,Z
	MOVWF	FSR		;Y, FSR=BKS
	DECFSZ	LEND		;N, NEXT
	GOTO	BK3
	DECFSZ	HEND
	GOTO	BK2
	CALL	CRLF
	GOTO	SBRK2

SBRKF	BCF	F_CF		;CLEAR CALLF MODE
	BCF	F_MCF
	CALL	CRLF
	MOVLW	LOW ET7		;SHOW: RETURN
	CALL	PROMPT
	GOTO	SBRK3

SBREAK	BTFSC	F_GI		;INITIAL G?
	GOTO	SBRK1		;N, SKIP
	MOVLW	90H		;INS SPEED RD-CMD
	CALL	TXINS
	CALL	RXINS		;WAIT SPEED VALUE
	MOVF	DB0,W
	MOVWF	DGN		;SAVE SPEED
	BSF	F_GI		;INITIAL SCAN MODE OFF

SBRK1	BSF	F_IN		;ENABLE (N)NEXT CMD ONLY ON BRK-RET
SBRK2	CALL	CRLF
	MOVLW	LOW ET2		;SHOW BREAK CMD HEADER
	CALL	PROMPT
	MOVF	BRKN,W		;SHOW BREAK NUMBER
	CALL	AOUT
SBRK3	CALL	OUT4S
	MOVLW	LOW ET3
	CALL	PROMPT

	MOVLW	10H		;INS W_TMP RD-CMD
	CALL	TXINS
	CALL	RXINS		;WAIT W_TMP DATA
	MOVF	DB0,W
	CALL	AOUT		;SHOW W_TMP HEX
	CALL	OUTS
	CALL	ADB0		;SHOW DB0 ASCII
	CALL	OUTS
	CALL	SBIN		;SHOW W_TMP BINARY
	CALL	OUT4S

	MOVLW	LOW ET4
	CALL	PROMPT
	MOVLW	20H		;INS STATUS_TMP RD-CMD
	CALL	TXINS
	CALL	RXINS		;WAIT STATUS_TMP DATA
	CALL	SBIN		;SHOW STATUS_TMP BINARY
	CALL	OUT4S

DV2416	CLRF	HEND		;DIVIDE 138800H/W1HL -> FREQ HEX (TMPH-L)
	CLRF	LEND

	MOVLW	13H		;DVDU
	MOVWF	TMP
	MOVLW	88H		;DVDH
	MOVWF	TMPH
	CLRF	TMPL		;DVDL
	MOVLW	.24
	MOVWF	I		;24 bit dividend

DV01	RLF	TMPL,W
	RLF	TMPH
	RLF	TMP
	RLF	LEND
	RLF	HEND
	RLF	TMPL
	MOVF	W1L,W
	SUBWF	LEND
	MOVF	W1H,W
	BTFSS	STATUS,C
	INCFSZ	W1H,W
	SUBWF	HEND
	BTFSC	STATUS,C
	BSF	TMPL,0
	BTFSC	TMPL,0
	GOTO	DV02
	ADDWF	HEND
	MOVF	W1L,W
	ADDWF	LEND
DV02	DECFSZ	I
	GOTO	DV01

	MOVF	DGN,W		;ADJUST RESULT TMPH-L/DGN
	MOVWF	I		;BASED ON SPEED MULTIPLIER
BK4	BTFSC	I,0
	GOTO	W2BCD
	CLRC
	RRF	TMP
	RRF	TMPH
	RRF	TMPL
	RRF	I
	GOTO	BK4

W2BCD	MOVLW	.16		;FREQ HEX (TMPH-L)-> 6xBCD TMP-HEND-LEND
	MOVWF	I
	CLRF	TMP		;BCDU
	CLRF	HEND		;BCDH
	CLRF	LEND		;BCDL

W_L16	RLF	TMPL
	RLF	TMPH
	RLF	LEND
	RLF	HEND
	RLF	TMP
	DECFSZ	I
	GOTO	W_L1

	MOVF	TMP,W		;SHOW BCD FREQ KHz
	ANDLW	0FH
	BTFSS	STATUS,Z
	GOTO	BCD1		;LZS
	SWAPF	HEND,W
	ANDLW	0FH		;@32MHz  +/- 2.50%
	BTFSS	STATUS,Z	;@16MHz  +/- 1.25%
	GOTO	BCD2		;@ 8MHz  +/- 0.62%
	MOVF	HEND,W		;@ 4MHz  +/- 0.31%
	ANDLW	0FH
	BTFSS	STATUS,Z
	GOTO	BCD3
	GOTO	BCD4
BCD1	MOVF	TMP,W
	CALL	LAOUT
BCD2	SWAPF	HEND,W
	CALL	LAOUT
BCD3	MOVF	HEND,W
	CALL	LAOUT
BCD4	MOVF	LEND,W
	CALL	AOUT
	CALL	OUTS
	MOVLW	'K'
	CALL	DOUT
	MOVLW	'H'
	CALL	DOUT
	MOVLW	'z'
	CALL	DOUT
	CALL	CRLF

	BTFSC	F_SM		;AUTO SHOW? F_SM=0?
	GOTO	MAIN		;N, EXIT
	CALL	CRLF		;Y, SHOW VARS
	GOTO	SH6

W_L1	MOVLW	LEND
	CALL	W_L2
	MOVLW	HEND
	CALL	W_L2
	MOVLW	TMP
	CALL	W_L2
	GOTO	W_L16

W_L2	MOVWF	FSR
	MOVLW	3
	ADDWF	INDF
	BTFSS	INDF,3
	SUBWF	INDF
	MOVLW	30H
	ADDWF	INDF
	BTFSS	INDF,7
	SUBWF	INDF
	RETURN

BK5	MOVWF	I		;SAVE SFR (W/S)POINTER
	MOVLW	'='
	CALL	DOUT
BK6	CALL	INPUT		;WAIT SFR WRITE DATA
	BTFSC	F_DIG		;DIGIT IN?
	GOTO	BK7		;Y, CONTINUE
	MOVLW	BLANK
	XORWF	CHAR,W
	BTFSC	STATUS,Z	;SPACE?
	GOTO	BK6		;Y, WAIT DIGIT
	GOTO	ABORT		;N, CMD ERROR
BK7	MOVLW	BLANK
	XORWF	CHAR,W
	BTFSC	STATUS,Z	;SPACE?
	GOTO	BK6		;Y, WAIT DIGIT
	MOVLW	CR
	XORWF	CHAR,W
	BTFSS	STATUS,Z	;CR?
	GOTO	ABORT		;N, CMD ERROR
	MOVF	I,W		;Y, WRITE SFR
	CALL	TXINS		;SFR INS WR-CMD
	MOVF	D0,W
	CALL	TXINS		;DATA INS WR-CMD
	GOTO	MAIN		;END CMD

;******** INP CMD	(ON PWR-UP-RST)
; USER PROGRAM INIT PULSE: I ------ LEDGREEN ON
; SEND 1ms PULSE AND START INSIDER ON-SCAN MODE

INP	BTFSC	F_BRK		;ON-PWR-UP RST?
	GOTO	STRT1		;N, CLEAR LAST BREAK LIST
	MOVLW	LOW ET5		;Y, SHOW: ON-SCAN
	CALL	PROMPT
	CALL	CRLF
	BSF	LGREEN		;LED GREEN ON

PULSE	BSF	BR1		;PULSE: OUTPUT '0' PULSE 1ms
	MOVLW	3BH		;RB7-> INSIDER PIN   RB6-> G0 PIN
	MOVWF	TRISB		;SET RB7-6 OUTPUT
	CLRF	STATUS
	MOVLW	3FH		;OUT '0' FOR 1ms
	MOVWF	PORTB
	MOVLW	07
	MOVWF	TMPH
	CLRF	TMPL
	DECFSZ	TMPL
	GOTO	$-1
	DECFSZ	TMPH
	GOTO	$-3
	MOVLW	0FFH
	MOVWF	PORTB
XG3	BSF	BR1		;X=1, SET X INPUT
	MOVLW	0FBH
	MOVWF	TRISB
	BCF	OPTION_REG,7	;RB PULL-UP ENABLE
	CLRF	STATUS

	GOTO	G06		;GOTO ON-SCAN MODE

;******** CALLF CMD	(ON-BREAK)
; USER FUNCTION EXECUTE: C adr(CR) -- LEDGREEN ON
; (ON-BREAK) SHOW:'ON-SCAN' -- RET-CMD PC=nnnnnn
; BREAKPOINT FF RESERVED

CALLF	CALL	XG1
	BTFSS	STATUS,Z	;CR?
	GOTO	ABORT		;N, CMD ERROR
	BTFSS	F_DIG		;Y, DIG INPUT?
	GOTO	ABORT		;N, ABORT
	BSF	F_CF		;F_CF =1 -> SET CALLF CMD
	BSF	F_MCF		;F_MCF=1 -> SET CALLF MODE
	GOTO	G03

XG1	BSF	F_D6		;6xDIGIT-HEX INPUT ON
XG2	CALL	INPUT		;WAIT INPUT
	MOVF	CHAR,W
	XORLW	BLANK
	BTFSC	STATUS,Z	;SPACE?
	GOTO	XG2		;Y, WAIT CR
	BCF	F_D6		;6xDIGIT-HEX INPUT OFF
	XORLW	CR^BLANK
	RETURN

;******** GO CMD
; USER PROGRAM EXECUTE: G (CR) -- LEDGREEN ON
; (ON-PWRST) SHOW:'ON-SCAN' WAIT FOR A BREAKPOINT AND READ SPEED
; (ON-BREAK) SHOW:'BRK-RET' RET-CMD TO TARGET AND SCAN.
; (ON-BREAK) G nnnnnn (CR) -- RET-CMD PC=nnnnnn

GO	BTFSS	F_BRK		;ON-BREAK?
	GOTO	G03		;N, INITIAL SCAN
	CALL	XG1		;Y, INPUT nnnnn
	BTFSS	STATUS,Z	;CR?
	GOTO	ABORT		;N, CMD ERROR
	BCF	F_CF		;F_CF=0 -> SET GO MODE
G02	MOVLW	LOW ET6		;SHOW: BRK-RET
	BTFSC	F_DIG		;G nnnnn?
G03	MOVLW	LOW ET5		;Y, SHOW: ON-SCAN
	CALL	PROMPT
	CALL	CRLF
	BCF	LRED		;LED RED OFF
	BSF	LGREEN		;LED GREEN ON

	BTFSS	F_BRK		;ON-BREAK?
	GOTO	XG3		;N, INITIAL SCAN
	BTFSS	F_DIG		;DIG INPUT?
	GOTO	G05		;N, SEND RET-CMD

	MOVF	D2,W		;BUILD PC-ADR CMD
	IORLW	0E0H		;SET CMD,765=111
	BTFSC	F_CF		;CALLF CMD?
	ANDLW	0BFH		;Y, SET CMD,765=101
	CALL	TXINS		;SEND PCU
	MOVF	D1,W
	CALL	TXINS		;SEND PCH
	MOVF	D0,W
	CALL	TXINS		;SEND PCL
	GOTO	G06

G05	MOVLW	80H		;SEND RET-CMD
	CALL	TXINS

G06	CALL	RXINS	;******* WAIT BREAKPOINT *******

	MOVF	BKI,W		;SAVE BREAKnn TO LAST BREAKS
	MOVWF	FSR
	MOVF	DB0,W
	MOVWF	INDF
	INCF	BKI

	MOVLW	BKE
	XORWF	FSR,W
	MOVLW	BKS
	BTFSC	STATUS,Z
	MOVWF	BKI

	BTFSC	PIR1,RCIF	;ANY KEY PRESSED?
	GOTO	G08		;Y, TAKE BREAK

	BTFSS	F_MCF		;CALLF MODE?
	GOTO	G07		;N, CONT
	INCF	DB0,W
	BTFSC	STATUS,Z	;DB0=0FFH?
	GOTO	G08		;Y, TAKE CALLF RET

G07	SWAPF	DB0,W		;N, CHECK BRK VALID STATUS
	ANDLW	0FH
	ADDLW	BP
	MOVWF	FSR		;READ BRK-N-GROUP
	MOVF	INDF,W
	BTFSC	STATUS,Z	;XBRK-GROUP?
	GOTO	G05		;Y, IGNORE BREAKPOINT

	BTFSC	INDF,7		;TBRK-GROUP?
	GOTO	G08		;N, TAKE BREAKPOINT
	MOVF	DB0,W		;Y, SHOW TRACE BREAKPOINT
	CALL	AOUT
	CALL	OUT2S		;2xSPACE SEP
	GOTO	G05		;RERUN TARGET

G08	BSF	F_BRK	;******* ON - BREAKPOINT *******
	BCF	LGREEN
	BSF	LRED		;LED RED ON
	MOVF	RCREG,W		;DUMMY READ

	BTFSS	F_MCF		;CALLF MODE?
	GOTO	G09		;N, CONT
	INCF	DB0,W
	BTFSC	STATUS,Z	;DB0=0FFH?
	GOTO	SBRKF		;Y, CALLF RET

G09	MOVF	DB0,W
	MOVWF	BRKN		;N, SAVE BREAKPOINT NUMBER
	GOTO	SBREAK		;SHOW BREAKPOINT DATA

;******** HELP CMD
; DISPLAY CMD HELP DATA

HELP	MOVLW	HIGH ETH1
	MOVWF	PCLATH		;SET LBL-PAGE
	MOVLW	LOW ETH1	;SET LBL-POINTER
	CALL	PROMPT
	MOVLW	HIGH ETH2
	MOVWF	PCLATH
	MOVLW	LOW ETH2
	CALL	PROMPT
MCRLF	CALL	CRLF
	GOTO	MAIN

;******** TBRK CMD
; TRACE BREAKPOINT: T n n  n (CR) -- n:0-F
; TRACE BREAKPOINT ON 16xGROUPS 0:00-0F 1:10-1F .. F:F0-FF
; T  (CR): SHOWS TBRKS: 0T 1T 2T -- FT
; TN (CR): TRACE ALL GROUPS 0n-Fn
; ANY KEY ENABLE NEXT TBRK

TBRK	MOVLW	0FH		;BRKG TRACE VALUE
	GOTO	VBRK+1

;******** XBRK CMD
; IGNORE BREAKPOINT: X n n  n (CR) -- n:0-F
; RESET BREAKPOINT ON 16xGROUPS 0:00-0F 1:10-1F .. F:F0-FF
; X  (CR): SHOWS XBRKS: 0X 1X 2X -- FX
; XN (CR): RESET ALL GROUPS 0n-Fn
; ANY KEY ENABLE NEXT XBRK

XBRK	CLRF	I		;BRKG IGNORE VALUE
	GOTO	V01

;******** VBRK CMD
; VALIDATE BREAKPOINT: V n n  n (CR) -- n:0-F
; SET BREAKPOINT ON 16xGROUPS 0:00-0F 1:10-1F .. F:F0-FF
; V  (CR): SHOWS VBRKS: 0v 1v 2v -- Fv
; VN (CR): SET ALL GROUPS 0n-Fn

VBRK	MOVLW	0FFH		;BRKG VALID VALUE
	MOVWF	I
V01	BCF	F_IN		;RESET DATA IN FLAG

V02	CALL	INPUT
	BTFSS	F_DIG		;HEX DIG IN?
	GOTO	V03		;N, CHECK CMD

	BSF	F_IN		;Y, SET DATA IN FLG
	MOVF	D0,W
	ANDLW	0FH		;READ LOW D0
	ADDLW	BP
	MOVWF	FSR		;FSR<-ADR(BP)+LOW DO
	MOVF	I,W
	MOVWF	INDF		;SAVE X/V/T VALUE -> BRKG(D0)

V03	MOVLW	BLANK
	XORWF	CHAR,W
	BTFSC	STATUS,Z	;BLANK SEP?
	GOTO	V02		;Y, CONTINUE

	BTFSS	F_IN		;VALUE INPUT?
	GOTO	V06		;N, CHECK CMD

V04	MOVLW	CR
	XORWF	CHAR,W
	BTFSS	STATUS,Z	;END CMD?
	GOTO	V10		;N, ERROR CMD
	MOVLW	BP
	MOVWF	FSR		;FSR<-ADR(BP)
	MOVLW	.16
	MOVWF	I		;BRKG COUNTER
V05	CALL	EW1
	INCF	FSR		;SAVE BRKG -> EEBRKG
	DECFSZ	I
	GOTO	V05
	GOTO	MAIN		;END CMD

V06	BSF	F_CMD
	MOVLW	'N'
	BCF	CHAR,5		;UPPER CHAR
	XORWF	CHAR,W
	BTFSS	STATUS,Z	;N?
	GOTO	V08		;N, SHOW BRKG
	MOVLW	.16		;Y, SET/RST/TRACE ALL BRKG
	MOVWF	TMP
	MOVLW	BP
	MOVWF	FSR		;FSR<-ADR(BP)
	MOVF	I,W
V07	MOVWF	INDF
	INCF	FSR
	DECFSZ	TMP
	GOTO	V07
	CALL	KEYIN		;WAIT CR TO CONFIRM
	GOTO	V04

V08	MOVLW	CR
	XORWF	CHAR,W
	BTFSS	STATUS,Z	;CR?
	GOTO	ABORT		;N, ERROR CMD
	MOVLW	BP		;Y, SHOW BRKG VALUES
	MOVWF	FSR		;FSR<-ADR(BP)
	MOVLW	.16
	MOVWF	I		;BRKG COUNTER
	CALL	OUT5S
V09	CALL	OUT2S
	MOVF	FSR,W
	CALL	LAOUT
	MOVF	INDF,W

	MOVLW	'X'		;SHOW: NX, NT or NV
	BTFSC	STATUS,Z
	GOTO	V11

	MOVLW	'T'
	BTFSC	INDF,7
	MOVLW	'v'

V11	CALL	DOUT
	INCF	FSR
	DECFSZ	I
	GOTO	V09
	GOTO	MAIN		;END CMD

V10	CALL	LBRKG		;RESTORE BRKG

ABORT	MOVLW	LOW ETA		;SHOW: CMD ERROR
	CALL	PROMPT
	GOTO	MAIN

LBRKG	MOVLW	BP		;EE(FSR)->(FSR)
	MOVWF	FSR
	MOVLW	.16
	MOVWF	I
	CALL	ER1
	INCF	FSR
	DECFSZ	I
	GOTO	$-3
	RETURN

;********************************************************************
;********************************************************************
; RXINS ROUTINE -- 1-Bit RECEPTION PROTOCOL FROM TARGET
; WAITS ONE START LOW PULSE WHICH WIDTH WILL BE SAVED ON W1H-L.
; THEN CALCULATES: W1 /2 -> W0, (W0+W1)/2= WT
; IF PULSE WIDTH= W0 or W1, THEN RX VALID AND RECEIVES 8 BITS OF DATA IN DB0.

;RECEIVE DATA
;		   W1        WT=384    W0
;   START|    '1'<---->512cyc      '0'<-->256cyc
;___ 512  __ D1   ____ D3 ____ D5 ____ D7 ______
;   |____|D0|____|D2  |__|D4  |__|D6  |__|


TOL	EQU	2

RXINS	BTFSS	X		;WAIT HIGH LEVEL
	GOTO	$-1		;OUT WHEN X->1

RX0	MOVLW	04		;INIT COUNTER OF 8 DATA PULSES
	MOVWF	BITC
	CLRF	W1H		;INIT W1
	CLRF	W1L

	BTFSC	X		;WAIT LOW PULSE
	GOTO	$-1		;OUT WHEN X->0

RX1	INCFSZ	W1L		;MEASURE 512-LOW PULSE WIDTH
RX2	GOTO	$+2		;IN Nx8cyc
	INCFSZ	W1H
	GOTO	$+2
	GOTO	RXINS		;OUT IF LOW OVERFLOW
	BTFSS	X
	GOTO	RX1		;CONTINUE UNTIL X->1

	BCF	STATUS,C	;W1 (512)
	RRF	W1H,W
	MOVWF	W0H
	MOVWF	WTH
	RRF	W1L,W
	MOVWF	W0L		;W0 (256) = W1 /2

	ADDWF	W1L,W
	MOVWF	WTL
	MOVF	W1H,W
	BTFSC	STATUS,C
	INCFSZ	W1H,W
	ADDWF	WTH
	RRF	WTH
	RRF	WTL		;WT (384) = (W1+W0)/2

	BCF	STATUS,C
	RRF	W0H,W
	MOVWF	TMPH
	RRF	W0L,W
	MOVWF	TMPL
	BCF	STATUS,C
	RRF	TMPH
	RRF	TMPL
	BCF	STATUS,C
	RRF	TMPH
	RRF	TMPL		;TMP = W1 /16

	MOVF	TMPH,W
	IORWF	TMPL,W
	BTFSC	STATUS,Z
	GOTO	RX0		;IF TMP=0, REINIT

	MOVLW	4		;INIT TMP
RX3	MOVWF	TMPL
	CLRF	TMPH

RX4	INCFSZ	TMPL		;MEASURE DATA-HIGH PULSE WIDTH
	GOTO	$+2		;IN Nx8cyc
	INCFSZ	TMPH
	GOTO	$+2
	GOTO	RX0		;OUT IF HIGH OVERFLOW
	BTFSC	X
	GOTO	RX4		;CONTINUE UNTIL X->0

	CALL	RTEST		;INPUT DATA BIT AND CHECK PULSE WITDH
	BTFSC	STATUS,C	;TOL > DIFF?
	GOTO	RX5

	MOVLW	6		;N, W1 = 5+1
	MOVWF	W1L
	CLRF	W1H
	MOVLW	4
	MOVWF	BITC
	GOTO	RX2		;RE-INIT FRAME

RX5	MOVLW	5		;INIT TMP
	MOVWF	TMPL
	CLRF	TMPH
	GOTO	$+1

RX6	INCFSZ	TMPL		;MEASURE DATA-LOW PULSE WIDTH
	GOTO	$+2		;IN Nx8cyc
	INCFSZ	TMPH
	GOTO	$+2
	GOTO	RXINS		;OUT IF LOW OVERFLOW
	BTFSS	X
	GOTO	RX6		;CONTINUE UNTIL X->1

	CALL	RTEST		;INPUT DATA BIT AND CHECK PULSE WITDH
	BTFSS	STATUS,C	;TOL > DIFF?
	GOTO	RX0		;N, OUT

	MOVLW	5

	DECFSZ	BITC
	GOTO	RX3
	RETURN			;RETURN RX DATA IN D0

RTEST	MOVF	WTL,W		;TMP-WT
	SUBWF	TMPL,W
	MOVF	WTH,W
	BTFSS	STATUS,C
	INCFSZ	WTH,W
	SUBWF	TMPH,W

	RRF	DB0		;C=DATA BIT - IF TMP > WT THEN C=1='1'
	GOTO	$+1

	BTFSS	DB0,7		;BIT = 1?
	GOTO	RTST0

	MOVF	W1L,W		;Y, TMP = TMP-W1
	SUBWF	TMPL
	MOVF	W1H,W
	BTFSS	STATUS,C
	INCFSZ	W1H,W
	SUBWF	TMPH

	GOTO	RTST1

RTST0	MOVF	W0L,W		;N, TMP = TMP-W0
	SUBWF	TMPL
	MOVF	W0H,W
	BTFSS	STATUS,C
	INCFSZ	W0H,W
	SUBWF	TMPH
	NOP

RTST1	MOVF	TMPL,W
	BTFSC	STATUS,C	;TMP < 0?
	GOTO	RTST2

	ADDLW	TOL		;Y, TOL + TMP
	MOVF	TMPH,W
	BTFSC	STATUS,C
	INCFSZ	TMPH,W
	ADDLW	00H
	NOP
	RETURN			;IF C=0 TOL < DIFF

RTST2	SUBLW	TOL		;N, TOL - TMP
	MOVF	TMPH,W
	BTFSS	STATUS,C
	INCFSZ	TMPH,W
	SUBLW	00H
	RETURN			;IF C=0 TOL < DIFF

;********************************************************************
; TXINS ROUTINE -- 1-Bit TRANSMISSION PROTOCOL TO TARGET
; TRANSMITS ONE START LOW PULSE OF WIDTH W1 AND
; 8 HIGH-DATA-PULSE OF WIDTH W1/W0 FOR EVERY DATA=1/0.

; KxFins			;K= TARGET #cyc (256,512)
; --------- = INS_COUNT		;Fins   = XTAL INSIDER 20MHz
; 8xFtarget			;Ftarget= XTAL Target 20KHz-64MHz

;TRANSMIT
;		  W1                   W0
;   START|    '1'<---->512cyc      '0'<-->256cyc
;___ 512  __ D1   ____ D3 ____ D5 ____ D7 ______
;   |____|D0|____|D2  |__|D4  |__|D6  |__|


TXINS	MOVWF	DB0		;SAVE TX-DATA
	BSF	X
	BSF	BR1		;SET X OUTPUT=1
	BCF	T
	CLRF	STATUS
	CALL	T0PULSE		;INITIAL FIXED DELAY

	MOVLW	5		;INIT COUNTER OF 8 DATA PULSES
	MOVWF	BITC
	BSF	STATUS,C	;INIT FIRST LOW PULSE= W1
	GOTO	TX2

TX1	RRF	DB0		;NEXT DATA BIT
	CALL	TPULSE
	RRF	DB0		;NEXT DATA BIT

TX2	BCF	X
	CALL	TPULSE
	CALL	TX3		;5x NOP
	BSF	X
	DECFSZ	BITC		;8 DATA PULSE?
	GOTO	TX1		;N, CONTINUE
	BSF	BR1		;Y, ENDS TRANSMISSION
	BSF	T		;X=1, SET X INPUT
TX3	CLRF	STATUS
	RETURN			;OUT


TPULSE	BTFSC	STATUS,C
	GOTO	T1PULSE

T0PULSE	MOVF	W0H,W		;W0-1 PULSE WIDTH
	MOVWF	TMPH
	MOVF	W0L,W

	GOTO	TX4

T1PULSE	MOVF	W1H,W		;W1-1 PULSE WIDTH
	MOVWF	TMPH
	MOVF	W1L,W

TX4	MOVWF	TMPL
	BTFSC	STATUS,Z
	DECF	TMPH
	DECF	TMPL
	BTFSS	STATUS,Z
	INCF	TMPH
	GOTO	TX5

	GOTO	$+1		;DELAY x8 INS-cyc
	NOP
TX5	DECFSZ	TMPL
	GOTO	$+2
	DECFSZ	TMPH
	GOTO	$-5
	RETURN

;********************************************************************
; INX16 ROUTINE -- 16x dd DIGIT INPUT TO D2-D17
; RETURN WITH LAST INPUT <> BLANK IN CHAR, S= dd COUNTER

INX16	CLRF	S		;INIT DATA COUNTER
FM4	CALL	INPUT		;WAIT DATA
	BTFSS	F_DIG		;IN DIGIT?
	GOTO	FM9		;N, CHECK CMD
	MOVLW	.15		;Y, SAVE DATA
	MOVWF	TMP		;MOVE DIGIT BUFFER
FM5	MOVLW	D1
	ADDWF	TMP,W
	MOVWF	FSR		;FSR<-TMP+ADR(D1)
	MOVF	INDF,W
	INCF	FSR		;D0->D2D3->..D17
	MOVWF	INDF
	DECFSZ	TMP
	GOTO	FM5
	MOVF	D0,W
	MOVWF	D2
	INCF	S

FM9	MOVF	CHAR,W
	XORLW	BLANK
	BTFSC	STATUS,Z	;DATA SEP?
	GOTO	FM4		;Y, WAIT OTHER DATA
	RETURN

;********************************************************************
; INPUT ROUTINE -- DIGIT INPUT TO D1D0 -- F_DIG=1 IF VALID HEX INPUT
; IF F_D6=1 6x DIGIT INPUT MODE ON
; OUT IF NOT-VALID-HEX-INPUT

INPUT	BCF	F_CMD		;RESET CMD - DIG FLAGS
	BCF	F_DIG
	CLRF	D0		;INIT INPUT
	CLRF	D1
	BTFSC	F_D6
	CLRF	D2		;IF 6x DIGIT INPUT MODE

IN1	CALL	KEYIN		;WAIT KEY IN
	BTFSS	F_HEX		;IF F_HEX=0, CMD INPUT -> CHAR
	RETURN

	MOVWF	CHAR
	SWAPF	CHAR
	MOVLW	100H-04
IN2	RLF	CHAR		;LW->LD0->HD0->LD1->HD1 IF F_D6=1 ->LD2->HD2
	RLF	D0
	RLF	D1
	BTFSC	F_D6
	RLF	D2
	ADDLW	1
	BTFSS	STATUS,Z
	GOTO	IN2
	BSF	F_DIG		;INDICATES VALID HEX
	GOTO	IN1		;CONTINUE UNTIL NOT VALID HEX INPUT

;********************************************************************
; KEYIN ROUTINE -- USER ASCII KEY INPUT --> CHAR
; F_CMD = 1 ASCII CMD  INPUT ONLY
; F_CMD = 0 ASCII CMD OR HEX DIGIT INPUT
; IF F_HEX=1 -- HEX OK --> CONVERT ASCII TO LOW HEX W-NIBBLE
; IF F_HEX=0 -- HEX BAD -> ASCII CMD IN CHAR

KEYIN	BTFSS	RCSTA,OERR	;OVER RUN ERROR?
	GOTO	$+4		;N, OUT
	BCF	RCSTA,CREN	;Y, CLEAR ERROR
	BSF	RCSTA,CREN
	MOVF	RCREG,W		;DUMMY READ OVER RUN DATA

	BTFSS	PIR1,RCIF	;WAIT DATA RX IN
	GOTO	$-1
	MOVF	RCREG,W		;READ 7-Bit ASCII -> CHAR
	MOVWF	CHAR
	BCF	CHAR,7

	XORLW	ESC		;ESC?
	MOVLW	BLANK		;Y, ECHO BLANK
	BTFSS	STATUS,Z
	MOVF	CHAR,W		;N, ECHO CHAR
	CALL	DOUT

	XORLW	CR		;CR?
	BTFSC	STATUS,Z
	CALL	OUTLF		;Y, ECHO LF

	BTFSC	CHAR,6		;CHAR,6=1?
	BCF	CHAR,5		;Y, UPPER CHAR

	MOVF	CHAR,W
	BTFSC	F_CMD		;F_CMD=1?
	RETURN			;Y, OUT
	BTFSS	CHAR,6		;HEX A-F?
	GOTO	HEXN		;N, HEX 0-9
	ANDLW	0DFH		;Y, HEX A-F
	ADDLW	0B9H
	BTFSC	STATUS,C
	GOTO	HBAD		;>F
	ADDLW	06H
	BTFSS	STATUS,C
	GOTO	HBAD		;<A
	ADDLW	0AH		;A-F
HOK	BSF	F_HEX
	RETURN
HEXN	ADDLW	0C6H
	BTFSC	STATUS,C
	GOTO	HBAD		;>9
	ADDLW	0AH
	BTFSC	STATUS,C
	GOTO	HOK		;0-9
HBAD	BCF	F_HEX		;<0
	RETURN

;********************************************************************
; PROMPT ROUTINE - DISPLAY STRINGS - W <-LOW-LBL  PCLATH <-HIGH-LBL

PROMPT	ADDLW	.255		;W <- LOW LBL-1
	MOVWF	TMP		;ONLY WORKS IF LOW TXT =00
PR1	BCF	F_HE		;RESET CRLF OUTPUT FLAG
	MOVF	TMP,W
	CALL	TXT		;FIND CHAR IN STRING
	XORLW	EOT		;END OF TXT?
	BTFSC	STATUS,Z
	RETURN			;Y, END
	XORLW	EOT		;N, RESTORES CHAR
	BTFSS	F_HE		;CRLF?
	CALL	DOUT		;N, DISPLAY
	INCF	TMP
	GOTO	PR1

HCRLF	BSF	F_HE		;SKIP CRLF OUTPUT

;********************************************************************
; OUTPUT CRLF

CRLF	MOVLW	CR
	CALL	DOUT
OUTLF	MOVLW	LF
	GOTO	DOUT

;********************************************************************
; OUTPUT BLANKS ROUTINES

OUT5S	CALL	OUTS
OUT4S	CALL	OUTS
OUT3S	CALL	OUTS
OUT2S	CALL	OUTS
OUTS	MOVLW	BLANK
	GOTO	DOUT

;********************************************************************
; DISPLAY DB0 BINARY DATA

SBIN	MOVLW	8		;SHOW DB0 BINARY FORMAT
	MOVWF	TMP
SB1	RLF	DB0
	MOVLW	'1'
	BTFSS	STATUS,C
	MOVLW	'0'
	CALL	DOUT
	DECFSZ	TMP
	GOTO	SB1
	RETURN

;********************************************************************
; ASCII ROUTINES
; ASCII OUT: HW->ASCII - LW->ASCII -->TX

AOUT	MOVWF	TMP		;SAVES W
	SWAPF	TMP,W
	CALL	LAOUT		;OUTPUT HIGH NIBBLE
	MOVF	TMP,W

; ASCII OUT: LW-ASCII ->TX

LAOUT	ANDLW	0FH		;GET LOW NIBBLE
	ADDLW	0F6H
	BTFSC	STATUS,C
	ADDLW	07H		;>9
	ADDLW	3AH		;<A

;********************************************************************
; DOUT ROUTINE -- TX W-DATA

DOUT	BTFSS	PIR1,TXIF
	GOTO	$-1
	MOVWF	TXREG
	RETURN

;********************************************************************
; SHOW DB0 20H < ASCII < 0FFH

ADB0	MOVF	DB0,W		;SHOW '.' IF ASCII = 0FFH or 7FH
	ANDLW	7FH
	XORLW	7FH
	BTFSC	STATUS,Z
	GOTO	ADB1
	MOVLW	20H
	SUBWF	DB0,W
	MOVF	DB0,W		;DB0 HEX > 20H
	BTFSS	STATUS,C
ADB1	MOVLW	'.'		;Y, SKIP ASCII
	GOTO	DOUT		;N, SHOW DB0

;********************************************************************
; EEPROM READ/WRITE ROUTINES
; EEPROM READ	    EEPROM(FSR)->(FSR)

ER3	MOVWF	FSR
ER1	MOVF	FSR,W
ER2	BTFSC	F_EER		;ECMD?
	ADDLW	EE_OFFSET	;Y, OFFSET EEADR

	BSF	BR1		;W=FSR
	MOVWF	EEADR
	BSF	EECON1,RD
	MOVF	EEDATA,W
	BCF	BR1
	MOVWF	INDF
	RETURN

; EEPROM WRITE  (FSR)->EEPROM(FSR)

EW1	MOVF	FSR,W
	BTFSC	F_EER		;ECMD?
	ADDLW	EE_OFFSET	;Y, OFFSET EEADR
	BSF	BR1
	MOVWF	EEADR
	MOVF	INDF,W
	MOVWF	EEDATA
	MOVLW	055H
	MOVWF	EECON2
	MOVLW	0AAH
	MOVWF	EECON2
	BSF	EECON1,WR
	BTFSC	EECON1,WR
	GOTO	$-1
	BCF	BR1
	RETURN

 page
;*********** HELP-TEXT *********************************************
;I/G/C{PCadr}	SCAN/BRKRET/CALLF
;E/D sss.fff	EE/DATA 4x sss-fff
;S[T]{nnn}	SET 16x nnn [T:AUTO]
;R[T] nnn	READ [T:LOOP] 8x nnn
;W[T] nnn dd	WRITE [T:16x] dd-> nnn
;Fsss{.fff} dd	WRITE 16x dd-> sss{-fff}
;V/X/T[N]n	SET/RST/TRACE BRKn [N:ALL]
;B{W/S dd}	BRK{WRITE dd->W/S}

	ORG	698H			;HELP TEXT AREA

ETH1	GOTO	HCRLF	;PAG-600
	RETLW	LF
	DT	"I/G/C{PCadr}",TAB,"SCAN/BRKRET/CALLF"
	GOTO	HCRLF
	DT	"E/D sss.fff",TAB,"EE/DATA 4x sss-fff"
	GOTO	HCRLF
	DT	"S[T]{nnn}",TAB,"SET 16x nnn [T:AUTO]"
	GOTO	HCRLF
	DT	"R[T] nnn"
	RETLW	EOT

TXT	ADDWF	PCL			;PAG-700
ETH2	DT	TAB,"READ [T:LOOP] 8x nnn"
	GOTO	HCRLF
	DT	"W[T] nnn dd",TAB,"WRITE [T:16x] dd-> nnn"
	GOTO	HCRLF
	DT	"Fsss{.fff} dd",TAB,"WRITE 16x dd-> sss{-fff}"
	GOTO	HCRLF
	DT	"V/X/T[N]n",TAB,"SET/RST/TRACE BRKn [N:ALL]"
	GOTO	HCRLF
	DT	"B{W/S dd}",TAB,"BRK{WRITE dd->W/S}"
	RETLW	EOT

;********************************************************************
; DISPLAY STRINGS - PAG-700

ET0	GOTO	HCRLF			;PWR PROMPT
	DT	TAB,TAB,"INSIDER V1r7",TAB,"(H)-> HELP",LF,EOT

ET1	GOTO	HCRLF			;MAIN PROMPT
	DT	"INS>",EOT

ET2	DT	"BRK:",EOT		;BREAK-1 PROMPT

ET3	DT	"W: ",EOT		;BREAK-2 PROMPT

ET4	DT	"STATUS: ",EOT		;BREAK-3 PROMPT

ET5	DT	TAB,"ON-SCAN",EOT	;ON-SCAN

ET6	DT	TAB,"BRK-RET",EOT	;BRK-RET

ET7	DT	"RETURN",EOT

ETA	GOTO	HCRLF			;CMD ERROR
	DT	TAB,"ERROR",EOT

ETB	DT	TAB,"AUTO-O",EOT	;AUTO-ON/OFF

;********************************************************************
	END
