;
*******************************************************;
DBUG12F : --DEBUG INSIDER-- TARGET ROUTINE VR 1.0;
ATANASIOS MELIMOPOULOS(pic.insider @gmail.com)

    ;
**************PLACE DEBUG ON / OFF MACRO AT USER - PROG -
    START

        DBRK EQU 1;
SET BREAKPOINTS - DEBUG ON / OFF 1 / 0 DBEE EQU 1;
SET EEPROM - READ -
    CMD ON / OFF 1 /
        0 noexpand

            BREAK MACRO bkn;
BREAKPOINT MACRO DEF IF DBRK == 1 MOVWF DB0 MOVLW bkn CALL DBUG ENDIF ENDM

    ;
**************PLACE AT BREAKPOINT ADR :

    BREAK nn;
BREAKPOINT NUMBER : 00H - 0FFH

    ;
**************REPLACE DBUG LABEL / VAR NAMES IF USED BY THE USER - PROG;
**************PLACE DBUG - DATA - ADR AT 12F6xxx UNUSED BANK - 0 DATA AREA;
**************PLACE THE FOLLOWING CODE AT THE END OF THE USER - PROG

                                                                    IF DBRK ==
    1;
DBUG12F : --DEBUG INSIDER-- TARGET ROUTINE VR 1.0

          DB0 EQU 5FH;
DEBUG BYTE 0 --W_TMP-- ----COMMON ACCESS AREA DB1 EQU 5EH;
DEBUG BYTE 1 --DATA RX / TX - COMMON ACCESS AREA DB2 EQU 5DH;
DEBUG BYTE 2 --STATUS_TMP DB3 EQU 5CH;
DEBUG BYTE 3 --FSR_TMP DB4 EQU 5BH;
DEBUG BYTE 4 --INTCON_TMP

    ;
**************USER - PROG INITIALIZED DEBUG PIN / PORT FOR DIGITAL I / O P EQU 2;
DEBUG PIN-- USER SELECTED GPIO I / O - PIN DBN EQU 1;
SPEED MULTIPLIER : 1x, 2x, 4x, 8x,
    16x

    ENDPROG EQU 3FFH;
USER SELECTED END - PROG - MEM - CHECK CPU TYPE - ;
------BE CAREFUL WITH OSCCAL / CONFIG BYTE AT THE END OF PROG -
    MEM-- ----

    ORG ENDPROG -
    .111 IF DBEE IFDEF EECON1 ORG ENDPROG -
    .125 ENDIF ENDIF

        DBUG MOVWF DB1;
SHOW BREAK NUMBER MOVF STATUS, W CLRF STATUS;
SET RBANK0 MOVWF DB2;
SAVE USER_STATUS MOVF INTCON, W BCF INTCON, GIE;
INT OFF MOVWF DB4;
SAVE USER_INTCON MOVF FSR, W MOVWF DB3;
SAVE USER_FSR

    ;
TRANSMIT;
START | '1' < ---- > 512cyc '0' < -- > 256cyc;
___ 512 __ D1 ____ D3 ____ D5 ____ D7 ______;
| ____ | D0 | ____ | D2 | __ | D4 | __ | D6 | __ |

    DG001 BSF GPIO,
    P;
TRANSMIT DBUG BYTE DB1 BSF STATUS, RP0;
SET HIGH OUTPUT LATCH, SET RBANK1 BCF TRISIO, P;
SET OUTPUT PIN CLRF STATUS;
SET RBANK0

    MOVLW .251 MOVWF FSR;
BIT COUNTER 8DATA CALL DG003;
PAUSE WIDTH 256cyc RLF DB1 GOTO DG006;
START LOW PULSE 512cyc

    DG002 RRF DB1;
4xW + 7 CYC DELAY MOVLW .258 - .127 / DBN;
IF C = 1, DATA PULSE WIDTH = 512cyc BTFSS STATUS, C DG003 MOVLW .258 - .63 / DBN;
IF C = 0, DATA PULSE WIDTH = 256cyc ADDLW 1 BTFSS STATUS,
   Z GOTO $ - 2 DG004 RETURN

                  DG005 CALL DG002 DG006 BCF GPIO,
   P CALL DG004;
4xNOP CALL DG002 BSF GPIO, P NOP INCFSZ FSR GOTO DG005

    ;
WAIT COMMAND;
CMD .7654 = 1XX0->BRK RET;
CMD .7654 = 1XX1->SEND DBN SPEED;
CMD .7654 = 01 --->WR CMD;
CMD .7654 = 00 --->RD CMD;
CMD .7654 = 0X00->POINT TO RAM DATA;
CMD .7654 = 0X01->POINT TO W_TMP;
CMD .7654 = 0X10->POINT TO STATUS_TMP;
CMD .7654 = 0X11->POINT TO EEPROM DATA;
CMD .0 ------>IRP - STATUS ADR BANK BIT

                        DG007 BSF STATUS,
    RP0;
SET RBANK1 BSF TRISIO, P;
SET INPUT PIN CLRF STATUS;
SET RBANK0 CALL DG014;
WAIT INPUT CMD BTFSS DB1, 7;
CMD, 7 = 0 ? GOTO DG008;
YES,
    RD / WR CMD

             MOVLW DBN BTFSC DB1,
    4;
SEND SPEED ? GOTO DG013;
Y, SEND DBN VALUE

    ;
RETURN FROM BREAKPOINT TO USER_MAIN

    MOVF DB3,
    W MOVWF FSR;
RESTORE USER_FSR MOVF DB4, W MOVWF INTCON;
RESTORE USER_INTCON MOVF DB2, W MOVWF STATUS;
RESTORE USER_STATUS SWAPF DB0 SWAPF DB0, W;
RESTORE USER_W RETURN;
RETURN FROM BREAKPOINT

    ;
COMMAND PARSER

    DG008 BTFSC DB1,
    4 BTFSS DB1, 5;
CMD, 54 = 11 ? GOTO DG009;
N, CONT

       CALL DG014;
WAIT INS - EEADR TO READ IF DBEE;
INCLUDE IF EEPROM RD - CMD WANTED IFDEF EECON1;
INCLUDE IF EEPROM EXIST BSF STATUS, RP0;
SET EEADR / DATA BANK MOVF EEADR, W MOVWF FSR;
SAVE USER - EEADR->FSR MOVF DB1, W MOVWF EEADR;
SET INS - EEADR MOVF EEDATA, W;
SAVE USER - EEDATA->W BSF EECON1, 0;
SET EEPROM RD - BIT XORWF EEDATA XORWF EEDATA, W;
W <->EEDATA XORWF EEDATA MOVWF DB1 MOVF FSR, W MOVWF EEADR;
RESTORE USER - EEADR CLRF STATUS;
SEL BANK0 ENDIF ENDIF GOTO DG001;
OUTPUT INS - EEDATA

                 DG009 MOVF DB1,
    W MOVWF FSR;
SAVE CMD->FSR MOVLW DB0 BTFSC DB1, 4;
IF W SELECTED BY CMD GOTO DG011;
POINT TO W_TMP BTFSC DB1, 5;
IF STATUS SELECTED BY CMD GOTO DG010;
POINT TO STATUS_TMP

    CALL DG014;
ELSE,
    WAIT INPUT ADR->DB1

        MOVLW 7FH ANDWF DB1,
    W XORLW STATUS;
IF ADR = > STATUS BTFSS STATUS, Z GOTO $ + 3 DG010 MOVLW DB2;
SET STATUS_TMP_ADR GOTO DG011 XORLW FSR ^ STATUS;
IF ADR = > FSR BTFSS STATUS, Z GOTO $ + 3 MOVLW DB3;
SET FSR_TMP_ADR GOTO DG011 XORLW INTCON ^ FSR;
IF ADR = > INTCON MOVLW DB4;
SET INTCON_TMP_ADR BTFSS STATUS, Z MOVF DB1, W;
INS - ADR->W

          DG011 BTFSS FSR,
    6;
CMD, 6 = 1 ? GOTO DG012;
NO->RD CMD MOVWF FSR;
YES->WR CMD, SET INS - ADR CALL DG014;
WAIT INPUT INS - DATA MOVF DB1, W MOVWF INDF;
WRITE DATA GOTO DG007;
GOTO INPUT CMD DG012 MOVWF FSR;
SET INS - ADR MOVF INDF, W;
READ DATA DG013 MOVWF DB1 GOTO DG001;
OUTPUT READ DATA

    ;
RECEIVE DATA;
START | '1' < ---- > 512cyc '0' < -- > 256cyc;
___ 512 __ D1 ____ D3 ____ D5 ____ D7 ______;
| ____ | D0 | ____ | D2 | __ | D4 | __ | D6 | __ |

    DG014 CLRF DB1;
INIT DBUG BYTE DB1 BTFSC GPIO, P;
WAIT '0' SYNC GOTO $ - 1 GOTO DG016

                           DG015 CLRW ADDLW 1 BTFSC GPIO,
    P;
WAIT '0' GOTO $ - 2;
COUNT WIDTH ADDLW .256 - .96 / DBN;
DATABIT = C RRF DB1 DG016 CLRW ADDLW 1 BTFSS GPIO, P;
WAIT '1' GOTO $ - 2;
COUNT WIDTH ADDLW .256 - .96 / DBN;
DATABIT = C RRF DB1 BTFSS STATUS, C;
CONTINUE UNTIL 8Bit RECEIVED GOTO DG015 RETURN

    ENDIF
