;*******************************************************
; DBUG12F: -- DEBUG INSIDER -- TARGET ROUTINE VR 1.1
; ATANASIOS MELIMOPOULOS (pic.insider@gmail.com)
; NEW DATA-INTERFACE
;************** PLACE DEBUG ON/OFF MACRO AT USER-PROG-START

DBRK	EQU	1	;SET BREAKPOINTS-DEBUG ON/OFF 1/0
DBEE	EQU	1	;SET EEPROM-READ-CMD   ON/OFF 1/0
 noexpand

BREAK	MACRO	bkn	;BREAKPOINT MACRO DEF
 IF DBRK==1
	MOVWF	DB0
	MOVLW	bkn
	CALL	DBUG
	BTFSC	DB1,6
	GOTO	DBGF
 ENDIF
	ENDM


;************** PLACE AT BREAKPOINT ADR:

	BREAK	nn	;BREAKPOINT NUMBER: 00H-0FFH


;************** REPLACE DBUG LABEL/VAR NAMES IF USED BY THE USER-PROG
;************** PLACE DBUG-DATA-ADR AT 16Fxxx UNUSED BANK-0 DATA AREA
;************** PLACE THE FOLLOWING CODE AT THE END OF THE USER-PROG

 IF DBRK==1	;DBUG12F: -- DEBUG INSIDER -- TARGET ROUTINE VR 1.1

DB0	EQU	5FH	;DEBUG BYTE 0  -- W_TMP ------ COMMON ACCESS AREA
DB1	EQU	5EH	;DEBUG BYTE 1  -- DATA RX/TX - COMMON ACCESS AREA
DB2	EQU	5DH	;DEBUG BYTE 2  -- STATUS_TMP
DB3	EQU	5CH	;DEBUG BYTE 3  -- FSR_TMP
DB4	EQU	5BH	;DEBUG BYTE 4  -- INTCON_TMP

;************** USER-PROG INITIALIZED DEBUG PIN/PORT FOR DIGITAL I/O
P	EQU	2	;DEBUG PIN     -- USER SELECTED GPIO I/O-PIN
DBN	EQU	1	;SPEED MULTIPLIER: 1x, 2x, 4x, 8x, 16x

ENDPROG	EQU	3FFH	;USER SELECTED END-PROG-MEM - CHECK CPU TYPE -
; ----- BE CAREFUL WITH OSCCAL/CONFIG BYTE AT THE END OF PROG-MEM ----

	ORG	ENDPROG-.144
 IF DBEE
 IFDEF	EECON1
	ORG	ENDPROG-.158
 ENDIF
 ENDIF

DBUG	MOVWF	DB1		;SHOW BREAK NUMBER
	MOVF	STATUS,W
	CLRF	STATUS		;SET RBANK0
	MOVWF	DB2		;SAVE USER_STATUS
	MOVF	INTCON,W
	BCF	INTCON,GIE	;INT OFF
	MOVWF	DB4		;SAVE USER_INTCON
	MOVF	FSR,W
	MOVWF	DB3		;SAVE USER_FSR

;TRANSMIT
;   START|    '1'<---->512cyc      '0'<-->256cyc
;___ 512  __ D1   ____ D3 ____ D5 ____ D7 ______
;   |____|D0|____|D2  |__|D4  |__|D6  |__|

DG001	BSF	GPIO,P		;TRANSMIT DBUG BYTE DB1
	BSF	STATUS,RP0	;SET HIGH OUTPUT LATCH, SET RBANK1
	BCF	TRISIO,P	;SET OUTPUT PIN
	CLRF	STATUS		;SET RBANK0

	MOVLW	.251
	MOVWF	FSR		;BIT COUNTER 8DATA
	CALL	DG003		;PAUSE WIDTH 256cyc
	RLF	DB1
	GOTO	DG006		;START LOW PULSE 512cyc

DG002	RRF	DB1		;4xW+7 CYC DELAY
	MOVLW	.258-.127/DBN	;IF C=1, DATA PULSE WIDTH=512cyc
	BTFSS	STATUS,C
DG003	MOVLW	.258-.63/DBN	;IF C=0, DATA PULSE WIDTH=256cyc
	ADDLW	1
	BTFSS	STATUS,Z
	GOTO	$-2
DG004	RETURN

DG005	CALL	DG002
DG006	BCF	GPIO,P
	CALL	DG004		;4xNOP
	CALL	DG002
	BSF	GPIO,P
	CLRWDT
	INCFSZ	FSR
	GOTO	DG005

;WAIT COMMAND
;CMD.7654 =111X -> QUIT SET PC  G nnnnnn
;CMD.7654 =101X -> QUIT SET PC  C nnnnnn
;CMD.7654 =1001 -> SEND DBN SPEED
;CMD.7654 =1000 -> QUIT BRK RET
;CMD.7654 =01-- -> WR CMD
;CMD.7654 =00-- -> RD CMD
;CMD.7654 =0X00 -> POINT TO RAM DATA
;CMD.7654 =0X01 -> POINT TO W_TMP
;CMD.7654 =0X10 -> POINT TO STATUS_TMP
;CMD.7654 =0X11 -> POINT TO EEPROM DATA

DG007	BSF	STATUS,RP0	;SET RBANK1
	BSF	TRISIO,P	;SET INPUT PIN
	CLRF	STATUS		;SET RBANK0
	CALL	DG016		;WAIT INPUT CMD
	BTFSS	DB1,7		;CMD,7=0?
	GOTO	DG009		;Y, RD/WR CMD

	BTFSC	DB1,6		;SET PC?
	RETURN			;Y, POP BREAK RET STACK
	BTFSS	DB1,5		;C nnnn?
	GOTO	$+5		;N, SKIP
	CALL	DBGF		;Y, CALL USER nnnn ADR
	MOVWF	DB0		;SAVE USER-W
	MOVLW	0FFH		;W=0FFH INDICATES CALL-RET
	GOTO	DBUG		;AND INIT RET-QUERY
	MOVLW	DBN
	BTFSC	DB1,4		;SEND DBN SPEED?
	GOTO	DG015		;Y, SEND DBN VALUE

;RETURN FROM BREAKPOINT TO USER_MAIN

DG008	MOVF	DB3,W
	MOVWF	FSR		;RESTORE USER_FSR
	MOVF	DB4,W
	MOVWF	INTCON		;RESTORE USER_INTCON
	MOVF	DB2,W
	MOVWF	STATUS		;RESTORE USER_STATUS
	SWAPF	DB0
	SWAPF	DB0,W		;RESTORE USER_W
	RETURN			;RETURN FROM BREAKPOINT

DBGF	CALL	DG016		;READ GO-PCH
	MOVF	DB1,W
	MOVWF	DB0
	CALL	DG016		;READ GO-PCL
	CALL	DG008
	MOVWF	PCLATH		;USER PCLATH AND W -> LOST
	SWAPF	DB1
	SWAPF	DB1,W		;SET PC=nnnn
	MOVWF	PCL		;GOTO USER nnnn ADR

;COMMAND PARSER

DG009	BTFSC	DB1,4
	BTFSS	DB1,5		;CMD,54=11?
	GOTO	DG010		;N, CONT

	CALL	DG016		;WAIT INS-EEADR TO READ
 IF DBEE			;INCLUDE IF EEPROM RD-CMD WANTED
 IFDEF	EECON1			;INCLUDE IF EEPROM EXIST
	BSF	STATUS,RP0	;SET EEADR/DATA BANK
	MOVF	EEADR,W
	MOVWF	FSR		;SAVE USER-EEADR -> FSR
	MOVF	DB1,W
	MOVWF	EEADR		;SET INS-EEADR
	MOVF	EEDATA,W	;SAVE USER-EEDATA -> W
	BSF	EECON1,0	;SET EEPROM RD-BIT
	XORWF	EEDATA
	XORWF	EEDATA,W	;W <-> EEDATA
	XORWF	EEDATA
	MOVWF	DB1
	MOVF	FSR,W
	MOVWF	EEADR		;RESTORE USER-EEADR
	CLRF	STATUS		;SEL BANK0 
 ENDIF
 ENDIF
	GOTO	DG001		;OUTPUT INS-EEDATA

DG010	MOVF	DB1,W
	MOVWF	FSR		;SAVE CMD -> FSR
	MOVLW	DB0
	BTFSC	DB1,4		;IF W SELECTED BY CMD
	GOTO	DG013		;POINT TO W_TMP
	BTFSC	DB1,5		;IF STATUS SELECTED BY CMD
	GOTO	DG011		;POINT TO STATUS_TMP

	CALL	DG016		;ELSE, WAIT INPUT ADR -> DB1

	MOVLW	7FH
	ANDWF	DB1,W
	XORLW	STATUS		;IF ADR=>STATUS
	BTFSS	STATUS,Z
	GOTO	$+3
DG011	MOVLW	DB2		;SET STATUS_TMP_ADR
	GOTO	DG013
	XORLW	FSR^STATUS	;IF ADR=>FSR
	BTFSS	STATUS,Z
	GOTO	$+3
	MOVLW	DB3		;SET FSR_TMP_ADR
	GOTO	DG013
	XORLW	INTCON^FSR	;IF ADR=>INTCON
	BTFSS	STATUS,Z
	GOTO	$+3
	MOVLW	DB4		;SET INTCON_TMP_ADR
	GOTO	DG013

	XORLW	DB0^INTCON	;IF ADR=>DB0
	BTFSC	STATUS,Z
	GOTO	DG012		;SKIP DB0

	MOVF	DB1,W
	XORLW	DB2
	BTFSS	STATUS,Z	;ADR=DB2?
	XORLW	DB3^DB2
	BTFSS	STATUS,Z	;ADR=DB3?
	XORLW	DB4^DB3
DG012	MOVLW	DB1
	BTFSS	STATUS,Z	;ADR=DB4?
	MOVF	DB1,W		;INS-ADR -> W

DG013	BTFSS	FSR,6		;CMD,6=1?
	GOTO	DG014		;N -> RD CMD, ANY ADR
	MOVWF	FSR		;Y -> WR CMD, SET INS-ADR
	CALL	DG016		;WAIT INPUT INS-DATA
	MOVF	DB1,W
	MOVWF	INDF		;WRITE DATA
	GOTO	DG007		;GOTO INPUT CMD
DG014	MOVWF	FSR		;SET INS-ADR
	MOVF	INDF,W		;READ DATA
DG015	MOVWF	DB1
	GOTO	DG001		;OUTPUT READ DATA

;RECEIVE DATA
;   START|    '1'<---->512cyc      '0'<-->256cyc
;___ 512  __ D1   ____ D3 ____ D5 ____ D7 ______
;   |____|D0|____|D2  |__|D4  |__|D6  |__|

DG016	CLRF	DB1		;INIT DBUG BYTE DB1
	CLRWDT
	BTFSC	GPIO,P		;WAIT '0' SYNC
	GOTO	$-2
	GOTO	DG018

DG017	CLRW
	CLRWDT
	ADDLW	1
	BTFSC	GPIO,P		;WAIT '0'
	GOTO	$-3		;COUNT WIDTH
	ADDLW	.256-.78/DBN	;DATABIT=C
	RRF	DB1
DG018	CLRW
	CLRWDT
	ADDLW	1
	BTFSS	GPIO,P		;WAIT '1'
	GOTO	$-3		;COUNT WIDTH
	ADDLW	.256-.78/DBN	;DATABIT=C
	RRF	DB1
	BTFSS	STATUS,C	;CONTINUE UNTIL 8Bit RECEIVED
	GOTO	DG017
	RETURN

 ENDIF
