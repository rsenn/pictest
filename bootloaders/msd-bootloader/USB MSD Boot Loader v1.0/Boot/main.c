/*********************************************************************
 *
 *                USB MSD Bootloader Firmware
 *
 *********************************************************************
 * FileName:        main.c
 * Dependencies:    See INCLUDES section below
 * Processor:       PIC18F4550
 * Compiler:        C18
 * Company:         Scene Double Ltd.
 * Author:			RPG
 * Version:			1.0
 * Date:			7/07/08
 *
 * Acknowledgement:	Uses (modified) Microchip v1.x USB Framework by R.Rojvanit
 *					Uses (modified) Microchip MSD framework
 *					Incorporates all known Microchip USB Framework bug fixes (via user forum) & framework revision 1.3
 *					Acknowledgments to PIC MSD example on SourceForge by Andrew Holbrook (aholbrook03@yahoo.com)
 *					Could not have done this work without:
 *						USB Mass Storage by Jan Axelson (www.lvr.com)
 *						Packet-Master USB12 Analyser (www.mqpelectronics.com)
 *
 *
 * License:			Copyright (C) 2007-2008  Scene Double Ltd. / Ray Gordon (ray@scene-double.co.uk)
 *
 *					This software is provided 'as-is', without any express or implied warranty.
 *					In no event will the authors be held liable for any damages arising from the use of this software.
 *
 * 					Permission is granted to anyone to use this software for any purpose, including commercial applications, 
 *					and to alter it and redistribute it freely, subject to the following restrictions:
 *
 * 					1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. 
 *					2. If you intend to use this software (or derivative) within a commercial product you must inform the authors prior to product release.
 *				    3. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
 * 					4. This notice may not be removed or altered from any source distribution.
 *
 *
 * Overview:		Mass storage bootloader using FAT emulation
 *					Loads firmware files generated by accompanying HEXStream windows application
 *					HEXStream can (optionally) encrypt the firmware file (obfuscation) in a simple manner which the Bootloader can decrypt
 *					The 'encryption' is included as a basic example. The same  start key needs to be entered into HEXStream and boot.h 
 *					Please consult accompanying documentation and the file boot.c for detailed description
 *					This example is for PICDEM FS USB board
 *					Bootloader will remain on Boot Mode unless valid user firmware is loaded and User Mode is requested.
 *					A two-byte EEPROM signature determines the current mode. 
 *
 * History: 
 * 		
 * 
 ********************************************************************/


/** INCLUDES **/
#include "Config_Fuses.h"
#include "boot.h"                 
#include "usb.h"                
#include "usb_compile_time_validation.h"								



/** GLOBAL VARIABLES **/

#pragma udata

STATUS_FLAGS status;													// Misc. status flags
byte Timer_1mS, Timer_200mS;											// Timers
byte EncryptVal;														// Encryption variable						
byte LineSum;															// Encryption variable

#ifdef ALLOW_USER_CONFIG
byte user_configuration[MAX_CONFIG] = {0};								// User configuration values are read into here
																		// Size to be modified by user
#else
byte	user_configuration[1];											// (to prevent linker errors)

#endif	
																

/** FUNCTION PROTOTYPES **/

static void InitializeSystem(void);


/** VECTOR REMAPPING **/

#pragma code _HIGH_INTERRUPT_VECTOR = 0x000008
void _high_ISR (void)
{
    _asm goto REMAP_HIGH_INTERRUPT_VECTOR _endasm
}

#pragma code _LOW_INTERRUPT_VECTOR = 0x000018
void _low_ISR (void)
{
    _asm goto REMAP_LOW_INTERRUPT_VECTOR _endasm
}


#pragma code

/******************************************************************************
 * Function:        void main(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        Main program entry point.
 *
 * Note:            None
 *****************************************************************************/
void main(void)
{


	// Boot Mode or User Mode?
	// Enter User Mode if:
	// 		Switch 2 is NOT pressed and User firmware is valid and we are no currently in Boot Mode	
	if( SWITCH_2 &&
		*((rom byte *)(FIRMWARE_VERSION + 2)) == FW_VALID &&
		ReadEE(BOOT_MODE_SIG1) != SIG1_VAL &&							// Look for boot signature
	    ReadEE(BOOT_MODE_SIG2) != SIG2_VAL )
	{
		    _asm goto REMAP_RESET_VECTOR _endasm						// User Mode	
	}


	// Boot Mode
	InitializeSystem();													// Initialise everything
		 
	
    while(1)															// Infinite task loop
    {  

		// Handle timers
		Handle_Timers();

#ifdef	FLASH_STATUS_LEDS
		// Flash status LEDS (to indicate Boot Mode)
		if( Timer_200mS == 5)
		{
			mToggle_Status_LEDS()
			Timer_200mS = 0;
		}
#endif			
	     
     	// Check bus status and service USB   
		USBCheckBusStatus();											          
        USBDriverService();  

		// Service the MSD class from which everything runs
        ProcessIO(); 

		// If quitting the bootloader we wait approx 2 secs (to allow SCSI commands to complete)
		// then detach from the USB and reset
		if( status.BOOT_MODE == FALSE )
		{										
			if (Timer_200mS > 3)										// ~2 sec up (manually tuned)?
			{
				WriteEE(0x00, BOOT_MODE_SIG1);							// Prepare return to User Mode by clearing EEPROM Boot Mode signature
				WriteEE(0x00, BOOT_MODE_SIG2);		
				USBSoftDetach();										// So, remove us from bus
				Timer_200mS = 0;
				while(Timer_200mS < 4)									// Wait ~800mS before re-attaching
					Handle_Timers();
				Reset_CPU();											// Reset to User Mode			
			}
		}
       
    } 
}

/******************************************************************************
 * Function:        static void InitializeSystem(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        InitializeSystem is a centralize initialization routine.
 *                  All required USB initialization routines are called from
 *                  here.
 *
 *****************************************************************************/
static void InitializeSystem(void)
{
	byte i;

 	mInitAllIO()														// Initialise PIC I/O
	mInitTimer_1mS()													// Start 1mS timer
	Timer_1mS = 0;														// Clear timers
	Timer_200mS = 0;
	status._Flags = 0;													// Clear status

	mSet_Status_LEDS(0x0F)												// Preset status LEDS (All On)

#ifdef ALLOW_USER_CONFIG
	for( i = 0; i < MAX_CONFIG; i++ )									// Buffer user configuration values 
		user_configuration[i] = ReadEE(i);																	
#endif 

	WriteEE(SIG1_VAL, BOOT_MODE_SIG1);									// Ensure EEPROM Boot Mode signature is written
	WriteEE(SIG2_VAL, BOOT_MODE_SIG2);
	status.BOOT_MODE = TRUE;											// Flag that we are in Boot Mode										


																		// USB Initialization
   	mInitializeUSBDriver();         									// See usbdrv.h
    DiskInit();          									            // MSD Initialization
																		// See msd.c
}


/******************************************************************************
 * Function:        void Handle_Timers(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        Handle 1mS & 200mS timers (approx)
 *
 *****************************************************************************/

void Handle_Timers(void)
{

	if(Timer_Flag_1mS)													// 1mS hardware timer rollover?
	{
		Timer_Flag_1mS = 0;												// Yes, so clear flag
		Timer_1mS++;													// Increment 1mS main timer

		if(Timer_1mS == 200)
		Timer_200mS++;													// Increment 200mS timer

	}
	
}


/******************************************************************************
 * Function:        void Reset_CPU(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        Software Reset the processor
 *
 * Notes:           In separate function to ensure optimisation of calling function is not affected.
 *
 *****************************************************************************/

void Reset_CPU(void)
{

	_asm reset _endasm

}

